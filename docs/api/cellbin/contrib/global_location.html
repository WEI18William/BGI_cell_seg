<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cellbin.contrib.global_location API documentation</title>
<meta name="description" content="求解拼接坐标" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cellbin.contrib.global_location</code></h1>
</header>
<section id="section-intro">
<p>求解拼接坐标</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
求解拼接坐标
&#34;&#34;&#34;
import os
import numpy as np

from sklearn.linear_model import LinearRegression
import scipy.spatial as spt

from cellbin.utils import clog


class GlobalLocation(object):
    &#34;&#34;&#34;
    只接收偏移量矩阵并求解最终拼接坐标
    &#34;&#34;&#34;
    def __init__(self):
        self.overlap = 0.1
        self.fov_loc_array = None
        self.offset_diff = None
        self.__init_value = 999
        self.horizontal_jitter = None
        self.vertical_jitter = None
        self.fov_height = None
        self.fov_width = None
        self.rows = None
        self.cols = None

    def set_jitter(self, h_j, v_j):
        assert h_j.shape == v_j.shape, &#34;Jitter ndim is diffient.&#34;
        h_j[np.where(h_j == -self.__init_value)] = self.__init_value
        v_j[np.where(v_j == -self.__init_value)] = self.__init_value
        self.horizontal_jitter = h_j
        self.vertical_jitter = v_j

    def set_image_shape(self, height, width):
        assert isinstance(height, int) or isinstance(height, float), &#34;Height type error.&#34;
        assert isinstance(width, int) or isinstance(width, float), &#34;Width type error.&#34;
        self.fov_height = int(height)
        self.fov_width = int(width)

    def set_size(self, rows, cols):
        assert isinstance(rows, int) or isinstance(rows, float), &#34;Rows type error.&#34;
        assert isinstance(cols, int) or isinstance(cols, float), &#34;Cols type error.&#34;
        self.rows = rows
        self.cols = cols

    def create_location(self, mode=&#39;cd&#39;):
        &#34;&#34;&#34;
        :param mode:生成最终坐标 &#39;cd&#39;
        &#34;&#34;&#34;
        if mode == &#39;cd&#39;:
            coord_model = CenterLrDiffuseStitch(self.rows, self.cols)
            coord_model.set_jitter(self.horizontal_jitter, self.vertical_jitter)
            coord_model.set_scope_loc_by_overlap(self.fov_height, self.fov_width, self.overlap)
            coord_model.multi_connect_domain_center()
            coord_model.multi_center_2_global_loc(center_start=False)

            self.offset_diff = coord_model.offset_diff
            self.fov_loc_array = coord_model.global_loc
        else:
            pass


##################################
&#34;&#34;&#34;坐标生成方法&#34;&#34;&#34;
##################################


class CenterLrDiffuseStitch:
    &#39;&#39;&#39;
        从组织连通域中心位置，推导出对应的拼接顺序
        * * *    * # *    # # #
        * # * -&gt; # # # -&gt; # # #
        * * *    * # *    # # #
    &#39;&#39;&#39;

    def __init__(self, rows, cols):
        &#39;&#39;&#39;
        rows, cols:总行列
        cumulate_thread: int: cumulative departure by centerLrDiffuseStitch
        src: 目标位置(row, col)
        &#39;&#39;&#39;
        self.scope_global_loc = None
        self.rows = rows
        self.cols = cols
        self.fov_height = None
        self.fov_width = None

        self.horizontal_jitter = None
        self.vertical_jitter = None
        self.domain_list = None

        # self.src = src

        self.jitter_mask = np.zeros((self.rows, self.cols), dtype=int) + 999  # 连通域信息
        self.stitch_mask = np.zeros((self.rows, self.cols), dtype=int)  # 待拼接索引
        self.stitch_masked = np.zeros((self.rows, self.cols), dtype=int)  # 已拼接的索引
        self.global_loc = np.zeros((self.rows, self.cols, 2), dtype=int) + 999
        self.stitch_list = list()  # 最终拼接顺序
        self.connect_domains = dict()  # 连通域信息
        self.domains = -1  # 连通域编号
        self.offset_diff = np.zeros(shape=(self.rows, self.cols)) - 1  # estimate accumulative error

        # output
        self.output = None
        self.cumulate_offset: int = 999

    def set_jitter(self, h_j, v_j):
        &#39;&#39;&#39;set jitter matrix&#39;&#39;&#39;
        assert h_j.shape == v_j.shape, &#34;jitter ndim is diffient&#34;
        self.horizontal_jitter = h_j
        self.vertical_jitter = v_j

    def set_scope_loc(self, scope_loc: np.ndarray):
        &#34;&#34;&#34;set scope loction&#34;&#34;&#34;
        self.scope_global_loc = scope_loc

    def set_fov_size(self, fov_height, fov_width):
        &#34;&#34;&#34;set fov size&#34;&#34;&#34;
        self.fov_height = fov_height
        self.fov_width = fov_width

    def set_scope_loc_by_overlap(self, h, w, overlap):
        &#34;&#34;&#34;计算显微镜的原始拼接坐标&#34;&#34;&#34;
        scope_global_loc = np.zeros(shape=(self.rows, self.cols, 2), dtype=np.int32)
        self.fov_height = h
        self.fov_width = w
        for i in range(self.rows):
            for j in range(self.cols):
                scope_global_loc[i, j, 0] = j * (w - int(w * overlap))
                scope_global_loc[i, j, 1] = i * (h - int(h * overlap))
        self.scope_global_loc = scope_global_loc

    def neighbor(self, row, col, mask: np.ndarray = None):
        &#34;&#34;&#34;
        Gets the unstitching FOV of the specified column position attachment
        &#34;&#34;&#34;
        if (col - 1) &lt; 0:
            left = None
        else:
            left = (row, col - 1)
        if (col + 1) &gt; (self.cols - 1):
            right = None
        else:
            right = (row, col + 1)
        if (row - 1) &lt; 0:
            up = None
        else:
            up = (row - 1, col)
        if (row + 1) &gt; (self.rows - 1):
            down = None
        else:
            down = (row + 1, col)

        if mask is None:
            return [left, right, up, down]
        else:
            mask_list = list()
            for it in [left, right, up, down]:
                if it and mask[it[0], it[1]] == 1:
                    mask_list.append(it)
            return mask_list

    def neighbor_fix(self, row, col):
        &#34;&#34;&#34;
        Gets the unstitching FOV of the specified column position attachment
        :return: [r, c]
        &#34;&#34;&#34;
        if (col - 1) &lt; 0:
            left = None
        else:
            left = [row, col - 1]
        if (col + 1) &gt; (self.cols - 1):
            right = None
        else:
            right = [row, col + 1]
        if (row - 1) &lt; 0:
            up = None
        else:
            up = [row - 1, col]
        if (row + 1) &gt; (self.rows - 1):
            down = None
        else:
            down = [row + 1, col]

        for it in [left, right, up, down]:
            if it:
                if self.stitch_masked[it[0], it[1]] == 1:
                    return it
        return None

    def _getFirstPosition(self, r=True):
        &#39;&#39;&#39;寻找连通域起始点
        r: 控制是否增加连通域名
        &#39;&#39;&#39;
        for i in range(self.rows):
            for j in range(self.cols):
                if self.horizontal_jitter[i, j, 0] != 999 or \
                        self.vertical_jitter[i, j, 0] != 999:
                    if (i, j) not in self.connect_domains.keys():
                        if r: self.domains += 1
                        return (i, j)
        return None

    def _indexIsLegal(self, index):
        &#39;&#39;&#39;判断行列号是否合法&#39;&#39;&#39;
        row, col = index
        if 0 &lt;= row &lt; self.rows and \
                0 &lt;= col &lt; self.cols:
            return True
        return False

    def caculateCenter(self, dst=None):
        &#39;&#39;&#39;递归寻找连通域&#39;&#39;&#39;
        h_flag = False
        new_dst = list()
        if dst is None:
            dst = [self._getFirstPosition()]

        for (row, col) in dst:
            # if (row, col) not in self.connect_domains.keys():
            self.connect_domains[(row, col)] = self.domains
            self.jitter_mask[row, col] = self.domains
            # temp = self.neighbor(row, col)

            if self.horizontal_jitter[row, col, 0] != 999:
                if self._indexIsLegal((row, col - 1)):
                    if (row, col - 1) not in self.connect_domains.keys():
                        self.connect_domains[(row, col - 1)] = self.domains
                        self.jitter_mask[row, col - 1] = self.domains
                        if (row, col - 1) not in new_dst:
                            new_dst.append((row, col - 1))
            if self.vertical_jitter[row, col, 0] != 999:
                if self._indexIsLegal((row - 1, col)):
                    if (row - 1, col) not in self.connect_domains.keys():
                        self.connect_domains[(row - 1, col)] = self.domains
                        self.jitter_mask[row - 1, col] = self.domains
                        if (row - 1, col) not in new_dst:
                            new_dst.append((row - 1, col))

            if self._indexIsLegal((row, col + 1)):
                if self.horizontal_jitter[row, col + 1, 0] != 999:
                    if (row, col + 1) not in self.connect_domains.keys():
                        if (row, col + 1) not in new_dst:
                            new_dst.append((row, col + 1))
            if self._indexIsLegal((row + 1, col)):
                if self.vertical_jitter[row + 1, col, 0] != 999:
                    if (row + 1, col) not in self.connect_domains.keys():
                        if (row + 1, col) not in new_dst:
                            new_dst.append((row + 1, col))

        if len(new_dst) != 0:
            self.caculateCenter(new_dst)
        else:
            return

    def caculateDomains(self):
        &#39;&#39;&#39;多次寻找连通域直至寻找结束
        return: jitter_mask, connect_domains
        &#39;&#39;&#39;
        while self._getFirstPosition(r=False) is not None:
            self.caculateCenter()

    @staticmethod
    def _get_nearest_pts(src_pt, dst_pts: np.ndarray):
        &#39;&#39;&#39;
        find nearst pts
        Args:
            scr_pts:
            dst_pts:
        Returns:
            nearst pts
        &#39;&#39;&#39;
        tree = spt.cKDTree(data=dst_pts[:, :2])
        distance, index = tree.query(src_pt, k=1)  # 寻找离模板点最佳的一个点.
        template_point = dst_pts[index]
        return distance, template_point

    def getStitchCenter(self, max_domain=None):
        &#39;&#39;&#39;获得最大连通域拼接中心索引&#39;&#39;&#39;
        if max_domain is None:
            max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
        else:
            assert max_domain in np.arange(0, self.domains + 1), &#39;max_domain input error&#39;
        domains = np.array([i for i in self.connect_domains.keys() if self.connect_domains[i] == max_domain])
        max_row = np.max(domains[:, 0])
        min_row = np.min(domains[:, 0])
        max_col = np.max(domains[:, 1])
        min_col = np.min(domains[:, 1])
        center_row = int((max_row + min_row) / 2)
        center_col = int((max_col + min_col) / 2)

        center = np.array([center_row, center_col])
        dis, (center_row, center_col) = self._get_nearest_pts(center, domains)

        return center_row, center_col

    &#39;&#39;&#39;
        接入studio
        &#39;&#39;&#39;

    def _getStitchOrder_by_domain(self, stitch_order):
        &#39;&#39;&#39;获得顺序&#39;&#39;&#39;
        domain_mask = np.zeros(shape=(self.rows, self.cols))
        stitch_list = []
        for key, value in self.connect_domains.items():
            if value == self.connect_domains[stitch_order[0]]:
                row, col = key
                domain_mask[row, col] = 1

        while len(stitch_order) &gt; 0:
            index = stitch_order.pop(0)
            if index not in stitch_list:
                stitch_list.append(index)
                nei = self.neighbor(index[0], index[1], mask=domain_mask)
                for i in nei:
                    if i not in stitch_list and i is not None:
                        stitch_order.append(i)
        return stitch_list

    def _getStitchOrder(self, stitch_order):
        &#39;&#39;&#39;获得顺序&#39;&#39;&#39;
        # domain_mask = np.zeros(shape=(self.rows,self.cols))
        stitch_list = []

        while len(stitch_order) &gt; 0:
            index = stitch_order.pop(0)
            if index not in stitch_list:
                stitch_list.append(index)
                nei = self.neighbor(index[0], index[1])
                for i in nei:
                    if i not in stitch_list and i is not None:
                        stitch_order.append(i)
        return stitch_list

    def centerToGlobal(self, row=None, col=None):
        &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
        支持外部键入row, col
        否则计算最大连通域中心
        &#39;&#39;&#39;
        if row is None and col is None:
            self.caculateDomains()
            row, col = self.getStitchCenter()
            self.center_row = row
            self.center_col = col

        stitch_order = list()
        stitch_order.append((row, col))
        self.stitch_list = self._getStitchOrder(stitch_order)

        # return stitch_order

    def domain_order(self, max_domain):
        &#34;&#34;&#34;
        从指定的连通域开始, 按顺序拼接对应的连通域
        :param max_domain:
        :return:
        &#34;&#34;&#34;
        first_row, first_col = self.getStitchCenter(max_domain)

        domain_order = [(first_col, first_col)]
        domain_list = []
        domain_pass_list = []
        while len(domain_order) &gt; 0:
            index = domain_order.pop(0)
            if index not in domain_pass_list:
                domain_pass_list.append(index)
                nei = self.neighbor(index[0], index[1])
                for i in nei:
                    if i is not None:
                        domain_order.append(i)
                        domain = self.jitter_mask[i[0], i[1]]
                        if domain not in domain_list and domain != 999:
                            domain_list.append(domain)
        return domain_list

    def multi_connect_domain_center(self):
        &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
        支持外部键入row, col
        否则计算最大连通域中心
        &#39;&#39;&#39;

        # if row is None and col is None:
        self.caculateDomains()
        max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
        self.domain_list = self.domain_order(max_domain)

    def multi_center_2_global_loc(self, center_start=False):
        self.lr = LinearRegression()
        self.lr.fit(np.array([[0, 0]]), np.array([[0, 0]]))
        if (self.lr.coef_ == 0).all():
            self.lr.coef_ = np.diag(np.ones(2))

        for domain_idx in self.domain_list:
            if center_start:
                center_row, center_col = int(self.rows / 2), int(self.cols / 2)
            else:
                center_row, center_col = self.getStitchCenter(max_domain=domain_idx)

            stitch_order = list()
            stitch_order.append((center_row, center_col))
            stitch_list = self._getStitchOrder_by_domain(stitch_order)
            self.get_domain_Loc(self.fov_height, self.fov_width, stitch_list)

            # 训练线性模型
            self.lr.fit(self.scope_global_loc[np.where(self.stitch_masked == 1)],
                        self.global_loc[np.where(self.stitch_masked == 1)])

        # 利用训练好的线性模型, 预测非连通域的fov坐标
        # for row,col in np.vstack(np.where(self.stitch_masked!=1)).T:
        #     self.global_loc[row,col] = self.lr.predict([self.scope_global_loc[row,col]])
        #     self.stitch_masked[row,col] = 1
        self.fix_unstitch_loc()
        self.cumulate_offset = np.max(self.offset_diff)
        # self.save_single_heatmap(self.offset_diff, name=&#34;offset_diff&#34;)

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])

    # def save_single_heatmap(self, img: np.ndarray, name):
    #     &#34;&#34;&#34;
    #     save one channel image
    #     &#34;&#34;&#34;
    #     import matplotlib.pyplot as plt
    #     import seaborn as sns
    #
    #     sns.set(font_scale=2)
    #     fig, ax1 = plt.subplots(nrows=1, ncols=1, figsize=(32, 32))
    #     cmap = sns.light_palette(&#39;purple&#39;, as_cmap=True)
    #
    #     ax1.set_title(&#34;{}&#34;.format(name))
    #     sns.heatmap(img, ax=ax1, cmap=cmap, annot=True)
    #     if self.output is not None:
    #         if os.path.exists(self.output) is not True:
    #             os.makedirs(self.output)
    #         save_path = os.path.join(self.output, &#34;Evaluate_{}.jpg&#34;.format(name))
    #         plt.savefig(save_path)

    def _fixJitter(self, ):
        &#39;&#39;&#39;
        补全横纵偏移量矩阵
        &#39;&#39;&#39;
        h_x = np.mean([self.horizontal_jitter[i, j, 0] for i in range(self.rows)
                       for j in range(self.cols) if self.horizontal_jitter[i, j, 0] != 999])
        h_y = np.mean([self.horizontal_jitter[i, j, 1] for i in range(self.rows)
                       for j in range(self.cols) if self.horizontal_jitter[i, j, 1] != 999])

        v_x = np.mean([self.vertical_jitter[i, j, 0] for i in range(self.rows)
                       for j in range(self.cols) if self.vertical_jitter[i, j, 0] != 999])
        v_y = np.mean([self.vertical_jitter[i, j, 1] for i in range(self.rows)
                       for j in range(self.cols) if self.vertical_jitter[i, j, 1] != 999])

        for i in range(self.rows):
            for j in range(self.cols):
                if self.horizontal_jitter[i, j, 0] == 999:
                    if j == 0:
                        self.horizontal_jitter[i, j] = [0, 0]
                    else:
                        if self.jitter_mask[i, j] == 999:
                            self.horizontal_jitter[i, j] = [round(h_x), round(h_y)]

                if self.vertical_jitter[i, j, 0] == 999:
                    if i == 0:
                        self.vertical_jitter[i, j] = [0, 0]
                    else:
                        if self.jitter_mask[i, j] == 999:
                            self.vertical_jitter[i, j] = [round(v_x), round(v_y)]

    def get_nearest_points(self, input_point, template_points):
        # 获得最靠近的点
        tree = spt.cKDTree(data=template_points)
        distance, index = tree.query(input_point, k=2)
        neighbor_point = template_points[index[0]]
        distance = np.abs(input_point - neighbor_point)
        return distance, neighbor_point

    def get_nearest_domain_fov(self, current_domain, stitched_loc):
        &#34;&#34;&#34;获得当前连通域中,离已经拼接的连通域最近的FOV的行列号&#34;&#34;&#34;
        min_distance = 999
        nearst_domain = None
        for fov_loc in current_domain:
            distance, _ = self.get_nearest_points(fov_loc, stitched_loc)
            distance = np.linalg.norm(distance)
            if distance &lt; min_distance:
                min_distance = distance
                nearst_domain = fov_loc
        return nearst_domain, min_distance

    def get_domain_Loc(self, height, width, stitch_list):
        &#39;&#39;&#39;获得连通域的拼接坐标&#39;&#39;&#39;
        # self._fixJitter()
        stitch_mask = np.zeros(shape=(self.rows, self.cols))

        nearest_domain_fov = None
        for item in stitch_list:
            row, col = item
            self.stitch_masked[row, col] = 1
            if np.max(stitch_mask) == 0:
                # 寻找当前domain中, 与已经拼接的连通域最近的fov
                stitched_loc = np.where(self.stitch_masked == 1)
                stitched_loc = np.vstack(stitched_loc).T
                nearest_domain_fov, _ = self.get_nearest_domain_fov(stitch_list, stitched_loc)
                stitch_mask[row, col] = 1
                self.global_loc[row, col] = self.lr.predict([self.scope_global_loc[row, col]])[0]
            else:
                mask_list = self.neighbor(row, col, mask=stitch_mask)

                loc_list = list()
                for mask in mask_list:
                    row_src, col_src = mask
                    temp_loc = None
                    if row_src &gt; row:
                        if self.vertical_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([0, height] + self.vertical_jitter[row_src, col_src])
                    elif row_src &lt; row:
                        if self.vertical_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([0, height] + self.vertical_jitter[row, col])
                    elif col_src &gt; col:
                        if self.horizontal_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([width, 0] + self.horizontal_jitter[row_src, col_src])
                    elif col_src &lt; col:
                        if self.horizontal_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([width, 0] + self.horizontal_jitter[row, col])
                    if temp_loc is not None:
                        loc_list.append(temp_loc)

                if len(loc_list) &gt;= 1:
                    loc_list = np.array(loc_list)
                    self.global_loc[row, col] = np.mean(loc_list, axis=0) + 0.5  # 四舍五入
                    stitch_mask[row, col] = 1
                    if len(loc_list) &gt;= 2:
                        ptp = np.ptp(loc_list, axis=0) / 2
                        self.offset_diff[row, col] = np.around(np.linalg.norm(ptp))
                else:
                    stitch_list.append(item)
                    # print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))
        # 将最近邻连通域的FOV的位置调整到预测位置
        if nearest_domain_fov is not None:
            nearest_fov_scope_loc = self.scope_global_loc[nearest_domain_fov[0], nearest_domain_fov[1]]
            offset = self.global_loc[nearest_domain_fov[0], nearest_domain_fov[1]] - \
                     self.lr.predict([nearest_fov_scope_loc])[0]
            offset = np.around(offset)
            self.global_loc[np.where(stitch_mask == 1)] -= offset.astype(np.int32)

    def getLastGlobalLoc(self, height, width):
        &#39;&#39;&#39;获得最终的拼接坐标&#39;&#39;&#39;
        self._fixJitter()
        for item in self.stitch_list:
            row, col = item
            if np.max(self.stitch_mask) == 0:
                self.stitch_mask[row, col] = 1
                self.global_loc[row, col] = [0, 0]
            else:
                mask_list = self.neighbor(row, col, mask=self.stitch_mask)
                self.stitch_mask[row, col] = 1
                loc_list = list()
                for mask in mask_list:
                    row_src, col_src = mask
                    temp_loc = None
                    if row_src &gt; row:
                        if self.vertical_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([0, height] + self.vertical_jitter[row_src, col_src])
                    elif row_src &lt; row:
                        if self.vertical_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([0, height] + self.vertical_jitter[row, col])
                    elif col_src &gt; col:
                        if self.horizontal_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([width, 0] + self.horizontal_jitter[row_src, col_src])
                    elif col_src &lt; col:
                        if self.horizontal_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([width, 0] + self.horizontal_jitter[row, col])
                    if temp_loc is not None:
                        loc_list.append(temp_loc)

                if len(loc_list) &gt;= 1:
                    loc_list = np.array(loc_list)
                    self.global_loc[row, col] = np.mean(loc_list, axis=0)
                # else:
                #     print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])

    def check_feature_matrix(self, feature_mask):
        &#39;&#39;&#39;
        check feature mask to get neighbor
        :return:
        &#39;&#39;&#39;
        rows, cols = feature_mask.shape
        fix_list = []
        for row in range(rows):
            for col in range(cols):
                if self.stitch_masked[row, col] == 0:
                    it = self.neighbor_fix(row, col)
                    if it is not None:
                        fix_list.append(([row, col], it))
        return fix_list

    def check_up_stitch(self, row, col):
        &#39;&#39;&#39;
        检查指定FOV的否可以基于以及算法出来的offset进行拼接
        :param row:
        :param col:
        :return:
        &#39;&#39;&#39;
        flag = False
        if self.stitch_masked[row, col] != 1 and row &gt;= 0 and col &gt;= 0:
            loc = []
            if col &gt; 0 and self.horizontal_jitter[row, col, 0] != 999 and self.stitch_masked[
                row, col - 1] == 1:  # left
                x0, y0 = self.global_loc[row, col - 1] + [self.fov_width, 0] + \
                         self.horizontal_jitter[row, col]
                loc.append([x0, y0])
            if row &lt; self.rows - 1 and self.vertical_jitter[row + 1, col, 0] != 999 and self.stitch_masked[
                row + 1, col] == 1:  # down
                x1, y1 = self.global_loc[row + 1, col] - (
                            [0, self.fov_height] + self.vertical_jitter[row + 1, col])
                loc.append([x1, y1])
            if col &lt; self.cols - 1 and self.horizontal_jitter[row, col + 1, 0] != 999 and self.stitch_masked[
                row, col + 1] == 1:  # right
                x2, y2 = self.global_loc[row, col + 1] - (
                            [self.fov_width, 0] + self.horizontal_jitter[row, col + 1])
                loc.append([x2, y2])
            if row &gt; 0 and self.vertical_jitter[row, col, 0] != 999 and self.stitch_masked[
                row - 1, col] == 1:  # up
                x3, y3 = self.global_loc[row - 1, col] + (
                        [0, self.fov_height] + self.vertical_jitter[row, col])
                loc.append([x3, y3])
            if len(loc) != 0:
                self.global_loc[row, col] = np.mean(loc, axis=0)
                self.stitch_masked[row, col] = 1
                flag = True  # 拼接成功
        return flag

    def fix_unstitch_loc(self):
        &#34;&#34;&#34;
        The unstitching FOV is estimated to be stitching
        :return:
        &#34;&#34;&#34;
        fix_list = self.check_feature_matrix(self.stitch_masked)
        h_mean_all = np.mean(
            [self.horizontal_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
             if self.horizontal_jitter[i, j, 0] != 999], axis=0)
        v_mean_all = np.mean([self.vertical_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
                              if self.vertical_jitter[i, j, 0] != 999], axis=0)
        while len(fix_list) &gt; 0:
            for dst, src in fix_list:
                flag = self.check_up_stitch(dst[0], dst[1])
                if flag is False:
                    h_mean_list = [self.horizontal_jitter[row, dst[1], :] for row in range(self.rows)
                                   if self.horizontal_jitter[row, dst[1], 0] != 999]  # 该列所有的offset取出来
                    h_mean = np.mean(h_mean_list, axis=0) if len(h_mean_list) &gt; 0 else h_mean_all
                    v_mean_list = [self.vertical_jitter[dst[0], col, :] for col in range(self.cols)
                                   if self.vertical_jitter[dst[0], col, 0] != 999]  # 该列所有的offset取出来
                    v_mean = np.mean(v_mean_list, axis=0) if len(v_mean_list) &gt; 0 else v_mean_all

                    # 找到当前dst四周已经拼好的neighbor
                    neighbor = self.neighbor(dst[0], dst[1], self.stitch_masked)
                    tem_loc = []
                    for src in neighbor:
                        if dst[0] &lt; src[0]:  # down
                            x0, y0 = self.global_loc[src[0], src[1]] - [0, self.fov_height] - v_mean
                            tem_loc.append([x0, y0])
                        elif dst[0] &gt; src[0]:  # up
                            x0, y0 = self.global_loc[src[0], src[1]] + [0, self.fov_height] + v_mean
                            tem_loc.append([x0, y0])
                        elif dst[1] &lt; src[1]:  # right
                            x0, y0 = self.global_loc[src[0], src[1]] - [self.fov_width, 0] - h_mean
                            tem_loc.append([x0, y0])
                        elif dst[1] &gt; src[1]:  # left
                            x0, y0 = self.global_loc[src[0], src[1]] + [self.fov_width, 0] + h_mean
                            tem_loc.append([x0, y0])
                        else:
                            clog.info(&#39;[{}-{}] fix_loc error!&#39;.format(dst[0], dst[1]))
                    if len(tem_loc) &gt; 0:
                        self.global_loc[dst[0], dst[1]] = np.mean(tem_loc, axis=0)
                        self.stitch_masked[dst[0], dst[1]] = 1
                        if len(tem_loc) &gt;= 2:
                            ptp = np.ptp(tem_loc, axis=0) / 2
                            self.offset_diff[dst[0], dst[1]] = np.around(np.linalg.norm(ptp))

            fix_list = self.check_feature_matrix(self.stitch_masked)
        self.global_loc = np.around(self.global_loc, decimals=0).astype(np.int32)

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch"><code class="flex name class">
<span>class <span class="ident">CenterLrDiffuseStitch</span></span>
<span>(</span><span>rows, cols)</span>
</code></dt>
<dd>
<div class="desc"><p>从组织连通域中心位置，推导出对应的拼接顺序
* * *
* # *
# # #
* # * -&gt; # # # -&gt; # # #
* * *
* # *
# # #</p>
<p>rows, cols:总行列
cumulate_thread: int: cumulative departure by centerLrDiffuseStitch
src: 目标位置(row, col)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CenterLrDiffuseStitch:
    &#39;&#39;&#39;
        从组织连通域中心位置，推导出对应的拼接顺序
        * * *    * # *    # # #
        * # * -&gt; # # # -&gt; # # #
        * * *    * # *    # # #
    &#39;&#39;&#39;

    def __init__(self, rows, cols):
        &#39;&#39;&#39;
        rows, cols:总行列
        cumulate_thread: int: cumulative departure by centerLrDiffuseStitch
        src: 目标位置(row, col)
        &#39;&#39;&#39;
        self.scope_global_loc = None
        self.rows = rows
        self.cols = cols
        self.fov_height = None
        self.fov_width = None

        self.horizontal_jitter = None
        self.vertical_jitter = None
        self.domain_list = None

        # self.src = src

        self.jitter_mask = np.zeros((self.rows, self.cols), dtype=int) + 999  # 连通域信息
        self.stitch_mask = np.zeros((self.rows, self.cols), dtype=int)  # 待拼接索引
        self.stitch_masked = np.zeros((self.rows, self.cols), dtype=int)  # 已拼接的索引
        self.global_loc = np.zeros((self.rows, self.cols, 2), dtype=int) + 999
        self.stitch_list = list()  # 最终拼接顺序
        self.connect_domains = dict()  # 连通域信息
        self.domains = -1  # 连通域编号
        self.offset_diff = np.zeros(shape=(self.rows, self.cols)) - 1  # estimate accumulative error

        # output
        self.output = None
        self.cumulate_offset: int = 999

    def set_jitter(self, h_j, v_j):
        &#39;&#39;&#39;set jitter matrix&#39;&#39;&#39;
        assert h_j.shape == v_j.shape, &#34;jitter ndim is diffient&#34;
        self.horizontal_jitter = h_j
        self.vertical_jitter = v_j

    def set_scope_loc(self, scope_loc: np.ndarray):
        &#34;&#34;&#34;set scope loction&#34;&#34;&#34;
        self.scope_global_loc = scope_loc

    def set_fov_size(self, fov_height, fov_width):
        &#34;&#34;&#34;set fov size&#34;&#34;&#34;
        self.fov_height = fov_height
        self.fov_width = fov_width

    def set_scope_loc_by_overlap(self, h, w, overlap):
        &#34;&#34;&#34;计算显微镜的原始拼接坐标&#34;&#34;&#34;
        scope_global_loc = np.zeros(shape=(self.rows, self.cols, 2), dtype=np.int32)
        self.fov_height = h
        self.fov_width = w
        for i in range(self.rows):
            for j in range(self.cols):
                scope_global_loc[i, j, 0] = j * (w - int(w * overlap))
                scope_global_loc[i, j, 1] = i * (h - int(h * overlap))
        self.scope_global_loc = scope_global_loc

    def neighbor(self, row, col, mask: np.ndarray = None):
        &#34;&#34;&#34;
        Gets the unstitching FOV of the specified column position attachment
        &#34;&#34;&#34;
        if (col - 1) &lt; 0:
            left = None
        else:
            left = (row, col - 1)
        if (col + 1) &gt; (self.cols - 1):
            right = None
        else:
            right = (row, col + 1)
        if (row - 1) &lt; 0:
            up = None
        else:
            up = (row - 1, col)
        if (row + 1) &gt; (self.rows - 1):
            down = None
        else:
            down = (row + 1, col)

        if mask is None:
            return [left, right, up, down]
        else:
            mask_list = list()
            for it in [left, right, up, down]:
                if it and mask[it[0], it[1]] == 1:
                    mask_list.append(it)
            return mask_list

    def neighbor_fix(self, row, col):
        &#34;&#34;&#34;
        Gets the unstitching FOV of the specified column position attachment
        :return: [r, c]
        &#34;&#34;&#34;
        if (col - 1) &lt; 0:
            left = None
        else:
            left = [row, col - 1]
        if (col + 1) &gt; (self.cols - 1):
            right = None
        else:
            right = [row, col + 1]
        if (row - 1) &lt; 0:
            up = None
        else:
            up = [row - 1, col]
        if (row + 1) &gt; (self.rows - 1):
            down = None
        else:
            down = [row + 1, col]

        for it in [left, right, up, down]:
            if it:
                if self.stitch_masked[it[0], it[1]] == 1:
                    return it
        return None

    def _getFirstPosition(self, r=True):
        &#39;&#39;&#39;寻找连通域起始点
        r: 控制是否增加连通域名
        &#39;&#39;&#39;
        for i in range(self.rows):
            for j in range(self.cols):
                if self.horizontal_jitter[i, j, 0] != 999 or \
                        self.vertical_jitter[i, j, 0] != 999:
                    if (i, j) not in self.connect_domains.keys():
                        if r: self.domains += 1
                        return (i, j)
        return None

    def _indexIsLegal(self, index):
        &#39;&#39;&#39;判断行列号是否合法&#39;&#39;&#39;
        row, col = index
        if 0 &lt;= row &lt; self.rows and \
                0 &lt;= col &lt; self.cols:
            return True
        return False

    def caculateCenter(self, dst=None):
        &#39;&#39;&#39;递归寻找连通域&#39;&#39;&#39;
        h_flag = False
        new_dst = list()
        if dst is None:
            dst = [self._getFirstPosition()]

        for (row, col) in dst:
            # if (row, col) not in self.connect_domains.keys():
            self.connect_domains[(row, col)] = self.domains
            self.jitter_mask[row, col] = self.domains
            # temp = self.neighbor(row, col)

            if self.horizontal_jitter[row, col, 0] != 999:
                if self._indexIsLegal((row, col - 1)):
                    if (row, col - 1) not in self.connect_domains.keys():
                        self.connect_domains[(row, col - 1)] = self.domains
                        self.jitter_mask[row, col - 1] = self.domains
                        if (row, col - 1) not in new_dst:
                            new_dst.append((row, col - 1))
            if self.vertical_jitter[row, col, 0] != 999:
                if self._indexIsLegal((row - 1, col)):
                    if (row - 1, col) not in self.connect_domains.keys():
                        self.connect_domains[(row - 1, col)] = self.domains
                        self.jitter_mask[row - 1, col] = self.domains
                        if (row - 1, col) not in new_dst:
                            new_dst.append((row - 1, col))

            if self._indexIsLegal((row, col + 1)):
                if self.horizontal_jitter[row, col + 1, 0] != 999:
                    if (row, col + 1) not in self.connect_domains.keys():
                        if (row, col + 1) not in new_dst:
                            new_dst.append((row, col + 1))
            if self._indexIsLegal((row + 1, col)):
                if self.vertical_jitter[row + 1, col, 0] != 999:
                    if (row + 1, col) not in self.connect_domains.keys():
                        if (row + 1, col) not in new_dst:
                            new_dst.append((row + 1, col))

        if len(new_dst) != 0:
            self.caculateCenter(new_dst)
        else:
            return

    def caculateDomains(self):
        &#39;&#39;&#39;多次寻找连通域直至寻找结束
        return: jitter_mask, connect_domains
        &#39;&#39;&#39;
        while self._getFirstPosition(r=False) is not None:
            self.caculateCenter()

    @staticmethod
    def _get_nearest_pts(src_pt, dst_pts: np.ndarray):
        &#39;&#39;&#39;
        find nearst pts
        Args:
            scr_pts:
            dst_pts:
        Returns:
            nearst pts
        &#39;&#39;&#39;
        tree = spt.cKDTree(data=dst_pts[:, :2])
        distance, index = tree.query(src_pt, k=1)  # 寻找离模板点最佳的一个点.
        template_point = dst_pts[index]
        return distance, template_point

    def getStitchCenter(self, max_domain=None):
        &#39;&#39;&#39;获得最大连通域拼接中心索引&#39;&#39;&#39;
        if max_domain is None:
            max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
        else:
            assert max_domain in np.arange(0, self.domains + 1), &#39;max_domain input error&#39;
        domains = np.array([i for i in self.connect_domains.keys() if self.connect_domains[i] == max_domain])
        max_row = np.max(domains[:, 0])
        min_row = np.min(domains[:, 0])
        max_col = np.max(domains[:, 1])
        min_col = np.min(domains[:, 1])
        center_row = int((max_row + min_row) / 2)
        center_col = int((max_col + min_col) / 2)

        center = np.array([center_row, center_col])
        dis, (center_row, center_col) = self._get_nearest_pts(center, domains)

        return center_row, center_col

    &#39;&#39;&#39;
        接入studio
        &#39;&#39;&#39;

    def _getStitchOrder_by_domain(self, stitch_order):
        &#39;&#39;&#39;获得顺序&#39;&#39;&#39;
        domain_mask = np.zeros(shape=(self.rows, self.cols))
        stitch_list = []
        for key, value in self.connect_domains.items():
            if value == self.connect_domains[stitch_order[0]]:
                row, col = key
                domain_mask[row, col] = 1

        while len(stitch_order) &gt; 0:
            index = stitch_order.pop(0)
            if index not in stitch_list:
                stitch_list.append(index)
                nei = self.neighbor(index[0], index[1], mask=domain_mask)
                for i in nei:
                    if i not in stitch_list and i is not None:
                        stitch_order.append(i)
        return stitch_list

    def _getStitchOrder(self, stitch_order):
        &#39;&#39;&#39;获得顺序&#39;&#39;&#39;
        # domain_mask = np.zeros(shape=(self.rows,self.cols))
        stitch_list = []

        while len(stitch_order) &gt; 0:
            index = stitch_order.pop(0)
            if index not in stitch_list:
                stitch_list.append(index)
                nei = self.neighbor(index[0], index[1])
                for i in nei:
                    if i not in stitch_list and i is not None:
                        stitch_order.append(i)
        return stitch_list

    def centerToGlobal(self, row=None, col=None):
        &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
        支持外部键入row, col
        否则计算最大连通域中心
        &#39;&#39;&#39;
        if row is None and col is None:
            self.caculateDomains()
            row, col = self.getStitchCenter()
            self.center_row = row
            self.center_col = col

        stitch_order = list()
        stitch_order.append((row, col))
        self.stitch_list = self._getStitchOrder(stitch_order)

        # return stitch_order

    def domain_order(self, max_domain):
        &#34;&#34;&#34;
        从指定的连通域开始, 按顺序拼接对应的连通域
        :param max_domain:
        :return:
        &#34;&#34;&#34;
        first_row, first_col = self.getStitchCenter(max_domain)

        domain_order = [(first_col, first_col)]
        domain_list = []
        domain_pass_list = []
        while len(domain_order) &gt; 0:
            index = domain_order.pop(0)
            if index not in domain_pass_list:
                domain_pass_list.append(index)
                nei = self.neighbor(index[0], index[1])
                for i in nei:
                    if i is not None:
                        domain_order.append(i)
                        domain = self.jitter_mask[i[0], i[1]]
                        if domain not in domain_list and domain != 999:
                            domain_list.append(domain)
        return domain_list

    def multi_connect_domain_center(self):
        &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
        支持外部键入row, col
        否则计算最大连通域中心
        &#39;&#39;&#39;

        # if row is None and col is None:
        self.caculateDomains()
        max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
        self.domain_list = self.domain_order(max_domain)

    def multi_center_2_global_loc(self, center_start=False):
        self.lr = LinearRegression()
        self.lr.fit(np.array([[0, 0]]), np.array([[0, 0]]))
        if (self.lr.coef_ == 0).all():
            self.lr.coef_ = np.diag(np.ones(2))

        for domain_idx in self.domain_list:
            if center_start:
                center_row, center_col = int(self.rows / 2), int(self.cols / 2)
            else:
                center_row, center_col = self.getStitchCenter(max_domain=domain_idx)

            stitch_order = list()
            stitch_order.append((center_row, center_col))
            stitch_list = self._getStitchOrder_by_domain(stitch_order)
            self.get_domain_Loc(self.fov_height, self.fov_width, stitch_list)

            # 训练线性模型
            self.lr.fit(self.scope_global_loc[np.where(self.stitch_masked == 1)],
                        self.global_loc[np.where(self.stitch_masked == 1)])

        # 利用训练好的线性模型, 预测非连通域的fov坐标
        # for row,col in np.vstack(np.where(self.stitch_masked!=1)).T:
        #     self.global_loc[row,col] = self.lr.predict([self.scope_global_loc[row,col]])
        #     self.stitch_masked[row,col] = 1
        self.fix_unstitch_loc()
        self.cumulate_offset = np.max(self.offset_diff)
        # self.save_single_heatmap(self.offset_diff, name=&#34;offset_diff&#34;)

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])

    # def save_single_heatmap(self, img: np.ndarray, name):
    #     &#34;&#34;&#34;
    #     save one channel image
    #     &#34;&#34;&#34;
    #     import matplotlib.pyplot as plt
    #     import seaborn as sns
    #
    #     sns.set(font_scale=2)
    #     fig, ax1 = plt.subplots(nrows=1, ncols=1, figsize=(32, 32))
    #     cmap = sns.light_palette(&#39;purple&#39;, as_cmap=True)
    #
    #     ax1.set_title(&#34;{}&#34;.format(name))
    #     sns.heatmap(img, ax=ax1, cmap=cmap, annot=True)
    #     if self.output is not None:
    #         if os.path.exists(self.output) is not True:
    #             os.makedirs(self.output)
    #         save_path = os.path.join(self.output, &#34;Evaluate_{}.jpg&#34;.format(name))
    #         plt.savefig(save_path)

    def _fixJitter(self, ):
        &#39;&#39;&#39;
        补全横纵偏移量矩阵
        &#39;&#39;&#39;
        h_x = np.mean([self.horizontal_jitter[i, j, 0] for i in range(self.rows)
                       for j in range(self.cols) if self.horizontal_jitter[i, j, 0] != 999])
        h_y = np.mean([self.horizontal_jitter[i, j, 1] for i in range(self.rows)
                       for j in range(self.cols) if self.horizontal_jitter[i, j, 1] != 999])

        v_x = np.mean([self.vertical_jitter[i, j, 0] for i in range(self.rows)
                       for j in range(self.cols) if self.vertical_jitter[i, j, 0] != 999])
        v_y = np.mean([self.vertical_jitter[i, j, 1] for i in range(self.rows)
                       for j in range(self.cols) if self.vertical_jitter[i, j, 1] != 999])

        for i in range(self.rows):
            for j in range(self.cols):
                if self.horizontal_jitter[i, j, 0] == 999:
                    if j == 0:
                        self.horizontal_jitter[i, j] = [0, 0]
                    else:
                        if self.jitter_mask[i, j] == 999:
                            self.horizontal_jitter[i, j] = [round(h_x), round(h_y)]

                if self.vertical_jitter[i, j, 0] == 999:
                    if i == 0:
                        self.vertical_jitter[i, j] = [0, 0]
                    else:
                        if self.jitter_mask[i, j] == 999:
                            self.vertical_jitter[i, j] = [round(v_x), round(v_y)]

    def get_nearest_points(self, input_point, template_points):
        # 获得最靠近的点
        tree = spt.cKDTree(data=template_points)
        distance, index = tree.query(input_point, k=2)
        neighbor_point = template_points[index[0]]
        distance = np.abs(input_point - neighbor_point)
        return distance, neighbor_point

    def get_nearest_domain_fov(self, current_domain, stitched_loc):
        &#34;&#34;&#34;获得当前连通域中,离已经拼接的连通域最近的FOV的行列号&#34;&#34;&#34;
        min_distance = 999
        nearst_domain = None
        for fov_loc in current_domain:
            distance, _ = self.get_nearest_points(fov_loc, stitched_loc)
            distance = np.linalg.norm(distance)
            if distance &lt; min_distance:
                min_distance = distance
                nearst_domain = fov_loc
        return nearst_domain, min_distance

    def get_domain_Loc(self, height, width, stitch_list):
        &#39;&#39;&#39;获得连通域的拼接坐标&#39;&#39;&#39;
        # self._fixJitter()
        stitch_mask = np.zeros(shape=(self.rows, self.cols))

        nearest_domain_fov = None
        for item in stitch_list:
            row, col = item
            self.stitch_masked[row, col] = 1
            if np.max(stitch_mask) == 0:
                # 寻找当前domain中, 与已经拼接的连通域最近的fov
                stitched_loc = np.where(self.stitch_masked == 1)
                stitched_loc = np.vstack(stitched_loc).T
                nearest_domain_fov, _ = self.get_nearest_domain_fov(stitch_list, stitched_loc)
                stitch_mask[row, col] = 1
                self.global_loc[row, col] = self.lr.predict([self.scope_global_loc[row, col]])[0]
            else:
                mask_list = self.neighbor(row, col, mask=stitch_mask)

                loc_list = list()
                for mask in mask_list:
                    row_src, col_src = mask
                    temp_loc = None
                    if row_src &gt; row:
                        if self.vertical_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([0, height] + self.vertical_jitter[row_src, col_src])
                    elif row_src &lt; row:
                        if self.vertical_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([0, height] + self.vertical_jitter[row, col])
                    elif col_src &gt; col:
                        if self.horizontal_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([width, 0] + self.horizontal_jitter[row_src, col_src])
                    elif col_src &lt; col:
                        if self.horizontal_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([width, 0] + self.horizontal_jitter[row, col])
                    if temp_loc is not None:
                        loc_list.append(temp_loc)

                if len(loc_list) &gt;= 1:
                    loc_list = np.array(loc_list)
                    self.global_loc[row, col] = np.mean(loc_list, axis=0) + 0.5  # 四舍五入
                    stitch_mask[row, col] = 1
                    if len(loc_list) &gt;= 2:
                        ptp = np.ptp(loc_list, axis=0) / 2
                        self.offset_diff[row, col] = np.around(np.linalg.norm(ptp))
                else:
                    stitch_list.append(item)
                    # print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))
        # 将最近邻连通域的FOV的位置调整到预测位置
        if nearest_domain_fov is not None:
            nearest_fov_scope_loc = self.scope_global_loc[nearest_domain_fov[0], nearest_domain_fov[1]]
            offset = self.global_loc[nearest_domain_fov[0], nearest_domain_fov[1]] - \
                     self.lr.predict([nearest_fov_scope_loc])[0]
            offset = np.around(offset)
            self.global_loc[np.where(stitch_mask == 1)] -= offset.astype(np.int32)

    def getLastGlobalLoc(self, height, width):
        &#39;&#39;&#39;获得最终的拼接坐标&#39;&#39;&#39;
        self._fixJitter()
        for item in self.stitch_list:
            row, col = item
            if np.max(self.stitch_mask) == 0:
                self.stitch_mask[row, col] = 1
                self.global_loc[row, col] = [0, 0]
            else:
                mask_list = self.neighbor(row, col, mask=self.stitch_mask)
                self.stitch_mask[row, col] = 1
                loc_list = list()
                for mask in mask_list:
                    row_src, col_src = mask
                    temp_loc = None
                    if row_src &gt; row:
                        if self.vertical_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([0, height] + self.vertical_jitter[row_src, col_src])
                    elif row_src &lt; row:
                        if self.vertical_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([0, height] + self.vertical_jitter[row, col])
                    elif col_src &gt; col:
                        if self.horizontal_jitter[row_src, col_src, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] - \
                                       ([width, 0] + self.horizontal_jitter[row_src, col_src])
                    elif col_src &lt; col:
                        if self.horizontal_jitter[row, col, 0] != 999:
                            temp_loc = self.global_loc[row_src, col_src] + \
                                       ([width, 0] + self.horizontal_jitter[row, col])
                    if temp_loc is not None:
                        loc_list.append(temp_loc)

                if len(loc_list) &gt;= 1:
                    loc_list = np.array(loc_list)
                    self.global_loc[row, col] = np.mean(loc_list, axis=0)
                # else:
                #     print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])

    def check_feature_matrix(self, feature_mask):
        &#39;&#39;&#39;
        check feature mask to get neighbor
        :return:
        &#39;&#39;&#39;
        rows, cols = feature_mask.shape
        fix_list = []
        for row in range(rows):
            for col in range(cols):
                if self.stitch_masked[row, col] == 0:
                    it = self.neighbor_fix(row, col)
                    if it is not None:
                        fix_list.append(([row, col], it))
        return fix_list

    def check_up_stitch(self, row, col):
        &#39;&#39;&#39;
        检查指定FOV的否可以基于以及算法出来的offset进行拼接
        :param row:
        :param col:
        :return:
        &#39;&#39;&#39;
        flag = False
        if self.stitch_masked[row, col] != 1 and row &gt;= 0 and col &gt;= 0:
            loc = []
            if col &gt; 0 and self.horizontal_jitter[row, col, 0] != 999 and self.stitch_masked[
                row, col - 1] == 1:  # left
                x0, y0 = self.global_loc[row, col - 1] + [self.fov_width, 0] + \
                         self.horizontal_jitter[row, col]
                loc.append([x0, y0])
            if row &lt; self.rows - 1 and self.vertical_jitter[row + 1, col, 0] != 999 and self.stitch_masked[
                row + 1, col] == 1:  # down
                x1, y1 = self.global_loc[row + 1, col] - (
                            [0, self.fov_height] + self.vertical_jitter[row + 1, col])
                loc.append([x1, y1])
            if col &lt; self.cols - 1 and self.horizontal_jitter[row, col + 1, 0] != 999 and self.stitch_masked[
                row, col + 1] == 1:  # right
                x2, y2 = self.global_loc[row, col + 1] - (
                            [self.fov_width, 0] + self.horizontal_jitter[row, col + 1])
                loc.append([x2, y2])
            if row &gt; 0 and self.vertical_jitter[row, col, 0] != 999 and self.stitch_masked[
                row - 1, col] == 1:  # up
                x3, y3 = self.global_loc[row - 1, col] + (
                        [0, self.fov_height] + self.vertical_jitter[row, col])
                loc.append([x3, y3])
            if len(loc) != 0:
                self.global_loc[row, col] = np.mean(loc, axis=0)
                self.stitch_masked[row, col] = 1
                flag = True  # 拼接成功
        return flag

    def fix_unstitch_loc(self):
        &#34;&#34;&#34;
        The unstitching FOV is estimated to be stitching
        :return:
        &#34;&#34;&#34;
        fix_list = self.check_feature_matrix(self.stitch_masked)
        h_mean_all = np.mean(
            [self.horizontal_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
             if self.horizontal_jitter[i, j, 0] != 999], axis=0)
        v_mean_all = np.mean([self.vertical_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
                              if self.vertical_jitter[i, j, 0] != 999], axis=0)
        while len(fix_list) &gt; 0:
            for dst, src in fix_list:
                flag = self.check_up_stitch(dst[0], dst[1])
                if flag is False:
                    h_mean_list = [self.horizontal_jitter[row, dst[1], :] for row in range(self.rows)
                                   if self.horizontal_jitter[row, dst[1], 0] != 999]  # 该列所有的offset取出来
                    h_mean = np.mean(h_mean_list, axis=0) if len(h_mean_list) &gt; 0 else h_mean_all
                    v_mean_list = [self.vertical_jitter[dst[0], col, :] for col in range(self.cols)
                                   if self.vertical_jitter[dst[0], col, 0] != 999]  # 该列所有的offset取出来
                    v_mean = np.mean(v_mean_list, axis=0) if len(v_mean_list) &gt; 0 else v_mean_all

                    # 找到当前dst四周已经拼好的neighbor
                    neighbor = self.neighbor(dst[0], dst[1], self.stitch_masked)
                    tem_loc = []
                    for src in neighbor:
                        if dst[0] &lt; src[0]:  # down
                            x0, y0 = self.global_loc[src[0], src[1]] - [0, self.fov_height] - v_mean
                            tem_loc.append([x0, y0])
                        elif dst[0] &gt; src[0]:  # up
                            x0, y0 = self.global_loc[src[0], src[1]] + [0, self.fov_height] + v_mean
                            tem_loc.append([x0, y0])
                        elif dst[1] &lt; src[1]:  # right
                            x0, y0 = self.global_loc[src[0], src[1]] - [self.fov_width, 0] - h_mean
                            tem_loc.append([x0, y0])
                        elif dst[1] &gt; src[1]:  # left
                            x0, y0 = self.global_loc[src[0], src[1]] + [self.fov_width, 0] + h_mean
                            tem_loc.append([x0, y0])
                        else:
                            clog.info(&#39;[{}-{}] fix_loc error!&#39;.format(dst[0], dst[1]))
                    if len(tem_loc) &gt; 0:
                        self.global_loc[dst[0], dst[1]] = np.mean(tem_loc, axis=0)
                        self.stitch_masked[dst[0], dst[1]] = 1
                        if len(tem_loc) &gt;= 2:
                            ptp = np.ptp(tem_loc, axis=0) / 2
                            self.offset_diff[dst[0], dst[1]] = np.around(np.linalg.norm(ptp))

            fix_list = self.check_feature_matrix(self.stitch_masked)
        self.global_loc = np.around(self.global_loc, decimals=0).astype(np.int32)

        self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
        self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateCenter"><code class="name flex">
<span>def <span class="ident">caculateCenter</span></span>(<span>self, dst=None)</span>
</code></dt>
<dd>
<div class="desc"><p>递归寻找连通域</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caculateCenter(self, dst=None):
    &#39;&#39;&#39;递归寻找连通域&#39;&#39;&#39;
    h_flag = False
    new_dst = list()
    if dst is None:
        dst = [self._getFirstPosition()]

    for (row, col) in dst:
        # if (row, col) not in self.connect_domains.keys():
        self.connect_domains[(row, col)] = self.domains
        self.jitter_mask[row, col] = self.domains
        # temp = self.neighbor(row, col)

        if self.horizontal_jitter[row, col, 0] != 999:
            if self._indexIsLegal((row, col - 1)):
                if (row, col - 1) not in self.connect_domains.keys():
                    self.connect_domains[(row, col - 1)] = self.domains
                    self.jitter_mask[row, col - 1] = self.domains
                    if (row, col - 1) not in new_dst:
                        new_dst.append((row, col - 1))
        if self.vertical_jitter[row, col, 0] != 999:
            if self._indexIsLegal((row - 1, col)):
                if (row - 1, col) not in self.connect_domains.keys():
                    self.connect_domains[(row - 1, col)] = self.domains
                    self.jitter_mask[row - 1, col] = self.domains
                    if (row - 1, col) not in new_dst:
                        new_dst.append((row - 1, col))

        if self._indexIsLegal((row, col + 1)):
            if self.horizontal_jitter[row, col + 1, 0] != 999:
                if (row, col + 1) not in self.connect_domains.keys():
                    if (row, col + 1) not in new_dst:
                        new_dst.append((row, col + 1))
        if self._indexIsLegal((row + 1, col)):
            if self.vertical_jitter[row + 1, col, 0] != 999:
                if (row + 1, col) not in self.connect_domains.keys():
                    if (row + 1, col) not in new_dst:
                        new_dst.append((row + 1, col))

    if len(new_dst) != 0:
        self.caculateCenter(new_dst)
    else:
        return</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateDomains"><code class="name flex">
<span>def <span class="ident">caculateDomains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>多次寻找连通域直至寻找结束
return: jitter_mask, connect_domains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caculateDomains(self):
    &#39;&#39;&#39;多次寻找连通域直至寻找结束
    return: jitter_mask, connect_domains
    &#39;&#39;&#39;
    while self._getFirstPosition(r=False) is not None:
        self.caculateCenter()</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.centerToGlobal"><code class="name flex">
<span>def <span class="ident">centerToGlobal</span></span>(<span>self, row=None, col=None)</span>
</code></dt>
<dd>
<div class="desc"><p>从中心开始拓展出所有拼接顺序
支持外部键入row, col
否则计算最大连通域中心</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centerToGlobal(self, row=None, col=None):
    &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
    支持外部键入row, col
    否则计算最大连通域中心
    &#39;&#39;&#39;
    if row is None and col is None:
        self.caculateDomains()
        row, col = self.getStitchCenter()
        self.center_row = row
        self.center_col = col

    stitch_order = list()
    stitch_order.append((row, col))
    self.stitch_list = self._getStitchOrder(stitch_order)

    # return stitch_order</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.check_feature_matrix"><code class="name flex">
<span>def <span class="ident">check_feature_matrix</span></span>(<span>self, feature_mask)</span>
</code></dt>
<dd>
<div class="desc"><p>check feature mask to get neighbor
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_feature_matrix(self, feature_mask):
    &#39;&#39;&#39;
    check feature mask to get neighbor
    :return:
    &#39;&#39;&#39;
    rows, cols = feature_mask.shape
    fix_list = []
    for row in range(rows):
        for col in range(cols):
            if self.stitch_masked[row, col] == 0:
                it = self.neighbor_fix(row, col)
                if it is not None:
                    fix_list.append(([row, col], it))
    return fix_list</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.check_up_stitch"><code class="name flex">
<span>def <span class="ident">check_up_stitch</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<div class="desc"><p>检查指定FOV的否可以基于以及算法出来的offset进行拼接
:param row:
:param col:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_up_stitch(self, row, col):
    &#39;&#39;&#39;
    检查指定FOV的否可以基于以及算法出来的offset进行拼接
    :param row:
    :param col:
    :return:
    &#39;&#39;&#39;
    flag = False
    if self.stitch_masked[row, col] != 1 and row &gt;= 0 and col &gt;= 0:
        loc = []
        if col &gt; 0 and self.horizontal_jitter[row, col, 0] != 999 and self.stitch_masked[
            row, col - 1] == 1:  # left
            x0, y0 = self.global_loc[row, col - 1] + [self.fov_width, 0] + \
                     self.horizontal_jitter[row, col]
            loc.append([x0, y0])
        if row &lt; self.rows - 1 and self.vertical_jitter[row + 1, col, 0] != 999 and self.stitch_masked[
            row + 1, col] == 1:  # down
            x1, y1 = self.global_loc[row + 1, col] - (
                        [0, self.fov_height] + self.vertical_jitter[row + 1, col])
            loc.append([x1, y1])
        if col &lt; self.cols - 1 and self.horizontal_jitter[row, col + 1, 0] != 999 and self.stitch_masked[
            row, col + 1] == 1:  # right
            x2, y2 = self.global_loc[row, col + 1] - (
                        [self.fov_width, 0] + self.horizontal_jitter[row, col + 1])
            loc.append([x2, y2])
        if row &gt; 0 and self.vertical_jitter[row, col, 0] != 999 and self.stitch_masked[
            row - 1, col] == 1:  # up
            x3, y3 = self.global_loc[row - 1, col] + (
                    [0, self.fov_height] + self.vertical_jitter[row, col])
            loc.append([x3, y3])
        if len(loc) != 0:
            self.global_loc[row, col] = np.mean(loc, axis=0)
            self.stitch_masked[row, col] = 1
            flag = True  # 拼接成功
    return flag</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.domain_order"><code class="name flex">
<span>def <span class="ident">domain_order</span></span>(<span>self, max_domain)</span>
</code></dt>
<dd>
<div class="desc"><p>从指定的连通域开始, 按顺序拼接对应的连通域
:param max_domain:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def domain_order(self, max_domain):
    &#34;&#34;&#34;
    从指定的连通域开始, 按顺序拼接对应的连通域
    :param max_domain:
    :return:
    &#34;&#34;&#34;
    first_row, first_col = self.getStitchCenter(max_domain)

    domain_order = [(first_col, first_col)]
    domain_list = []
    domain_pass_list = []
    while len(domain_order) &gt; 0:
        index = domain_order.pop(0)
        if index not in domain_pass_list:
            domain_pass_list.append(index)
            nei = self.neighbor(index[0], index[1])
            for i in nei:
                if i is not None:
                    domain_order.append(i)
                    domain = self.jitter_mask[i[0], i[1]]
                    if domain not in domain_list and domain != 999:
                        domain_list.append(domain)
    return domain_list</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.fix_unstitch_loc"><code class="name flex">
<span>def <span class="ident">fix_unstitch_loc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The unstitching FOV is estimated to be stitching
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_unstitch_loc(self):
    &#34;&#34;&#34;
    The unstitching FOV is estimated to be stitching
    :return:
    &#34;&#34;&#34;
    fix_list = self.check_feature_matrix(self.stitch_masked)
    h_mean_all = np.mean(
        [self.horizontal_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
         if self.horizontal_jitter[i, j, 0] != 999], axis=0)
    v_mean_all = np.mean([self.vertical_jitter[i, j, :] for i in range(self.rows) for j in range(self.cols)
                          if self.vertical_jitter[i, j, 0] != 999], axis=0)
    while len(fix_list) &gt; 0:
        for dst, src in fix_list:
            flag = self.check_up_stitch(dst[0], dst[1])
            if flag is False:
                h_mean_list = [self.horizontal_jitter[row, dst[1], :] for row in range(self.rows)
                               if self.horizontal_jitter[row, dst[1], 0] != 999]  # 该列所有的offset取出来
                h_mean = np.mean(h_mean_list, axis=0) if len(h_mean_list) &gt; 0 else h_mean_all
                v_mean_list = [self.vertical_jitter[dst[0], col, :] for col in range(self.cols)
                               if self.vertical_jitter[dst[0], col, 0] != 999]  # 该列所有的offset取出来
                v_mean = np.mean(v_mean_list, axis=0) if len(v_mean_list) &gt; 0 else v_mean_all

                # 找到当前dst四周已经拼好的neighbor
                neighbor = self.neighbor(dst[0], dst[1], self.stitch_masked)
                tem_loc = []
                for src in neighbor:
                    if dst[0] &lt; src[0]:  # down
                        x0, y0 = self.global_loc[src[0], src[1]] - [0, self.fov_height] - v_mean
                        tem_loc.append([x0, y0])
                    elif dst[0] &gt; src[0]:  # up
                        x0, y0 = self.global_loc[src[0], src[1]] + [0, self.fov_height] + v_mean
                        tem_loc.append([x0, y0])
                    elif dst[1] &lt; src[1]:  # right
                        x0, y0 = self.global_loc[src[0], src[1]] - [self.fov_width, 0] - h_mean
                        tem_loc.append([x0, y0])
                    elif dst[1] &gt; src[1]:  # left
                        x0, y0 = self.global_loc[src[0], src[1]] + [self.fov_width, 0] + h_mean
                        tem_loc.append([x0, y0])
                    else:
                        clog.info(&#39;[{}-{}] fix_loc error!&#39;.format(dst[0], dst[1]))
                if len(tem_loc) &gt; 0:
                    self.global_loc[dst[0], dst[1]] = np.mean(tem_loc, axis=0)
                    self.stitch_masked[dst[0], dst[1]] = 1
                    if len(tem_loc) &gt;= 2:
                        ptp = np.ptp(tem_loc, axis=0) / 2
                        self.offset_diff[dst[0], dst[1]] = np.around(np.linalg.norm(ptp))

        fix_list = self.check_feature_matrix(self.stitch_masked)
    self.global_loc = np.around(self.global_loc, decimals=0).astype(np.int32)

    self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
    self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.getLastGlobalLoc"><code class="name flex">
<span>def <span class="ident">getLastGlobalLoc</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>获得最终的拼接坐标</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLastGlobalLoc(self, height, width):
    &#39;&#39;&#39;获得最终的拼接坐标&#39;&#39;&#39;
    self._fixJitter()
    for item in self.stitch_list:
        row, col = item
        if np.max(self.stitch_mask) == 0:
            self.stitch_mask[row, col] = 1
            self.global_loc[row, col] = [0, 0]
        else:
            mask_list = self.neighbor(row, col, mask=self.stitch_mask)
            self.stitch_mask[row, col] = 1
            loc_list = list()
            for mask in mask_list:
                row_src, col_src = mask
                temp_loc = None
                if row_src &gt; row:
                    if self.vertical_jitter[row_src, col_src, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] - \
                                   ([0, height] + self.vertical_jitter[row_src, col_src])
                elif row_src &lt; row:
                    if self.vertical_jitter[row, col, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] + \
                                   ([0, height] + self.vertical_jitter[row, col])
                elif col_src &gt; col:
                    if self.horizontal_jitter[row_src, col_src, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] - \
                                   ([width, 0] + self.horizontal_jitter[row_src, col_src])
                elif col_src &lt; col:
                    if self.horizontal_jitter[row, col, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] + \
                                   ([width, 0] + self.horizontal_jitter[row, col])
                if temp_loc is not None:
                    loc_list.append(temp_loc)

            if len(loc_list) &gt;= 1:
                loc_list = np.array(loc_list)
                self.global_loc[row, col] = np.mean(loc_list, axis=0)
            # else:
            #     print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))

    self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
    self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.getStitchCenter"><code class="name flex">
<span>def <span class="ident">getStitchCenter</span></span>(<span>self, max_domain=None)</span>
</code></dt>
<dd>
<div class="desc"><p>获得最大连通域拼接中心索引</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStitchCenter(self, max_domain=None):
    &#39;&#39;&#39;获得最大连通域拼接中心索引&#39;&#39;&#39;
    if max_domain is None:
        max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
    else:
        assert max_domain in np.arange(0, self.domains + 1), &#39;max_domain input error&#39;
    domains = np.array([i for i in self.connect_domains.keys() if self.connect_domains[i] == max_domain])
    max_row = np.max(domains[:, 0])
    min_row = np.min(domains[:, 0])
    max_col = np.max(domains[:, 1])
    min_col = np.min(domains[:, 1])
    center_row = int((max_row + min_row) / 2)
    center_col = int((max_col + min_col) / 2)

    center = np.array([center_row, center_col])
    dis, (center_row, center_col) = self._get_nearest_pts(center, domains)

    return center_row, center_col</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_domain_Loc"><code class="name flex">
<span>def <span class="ident">get_domain_Loc</span></span>(<span>self, height, width, stitch_list)</span>
</code></dt>
<dd>
<div class="desc"><p>获得连通域的拼接坐标</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_domain_Loc(self, height, width, stitch_list):
    &#39;&#39;&#39;获得连通域的拼接坐标&#39;&#39;&#39;
    # self._fixJitter()
    stitch_mask = np.zeros(shape=(self.rows, self.cols))

    nearest_domain_fov = None
    for item in stitch_list:
        row, col = item
        self.stitch_masked[row, col] = 1
        if np.max(stitch_mask) == 0:
            # 寻找当前domain中, 与已经拼接的连通域最近的fov
            stitched_loc = np.where(self.stitch_masked == 1)
            stitched_loc = np.vstack(stitched_loc).T
            nearest_domain_fov, _ = self.get_nearest_domain_fov(stitch_list, stitched_loc)
            stitch_mask[row, col] = 1
            self.global_loc[row, col] = self.lr.predict([self.scope_global_loc[row, col]])[0]
        else:
            mask_list = self.neighbor(row, col, mask=stitch_mask)

            loc_list = list()
            for mask in mask_list:
                row_src, col_src = mask
                temp_loc = None
                if row_src &gt; row:
                    if self.vertical_jitter[row_src, col_src, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] - \
                                   ([0, height] + self.vertical_jitter[row_src, col_src])
                elif row_src &lt; row:
                    if self.vertical_jitter[row, col, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] + \
                                   ([0, height] + self.vertical_jitter[row, col])
                elif col_src &gt; col:
                    if self.horizontal_jitter[row_src, col_src, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] - \
                                   ([width, 0] + self.horizontal_jitter[row_src, col_src])
                elif col_src &lt; col:
                    if self.horizontal_jitter[row, col, 0] != 999:
                        temp_loc = self.global_loc[row_src, col_src] + \
                                   ([width, 0] + self.horizontal_jitter[row, col])
                if temp_loc is not None:
                    loc_list.append(temp_loc)

            if len(loc_list) &gt;= 1:
                loc_list = np.array(loc_list)
                self.global_loc[row, col] = np.mean(loc_list, axis=0) + 0.5  # 四舍五入
                stitch_mask[row, col] = 1
                if len(loc_list) &gt;= 2:
                    ptp = np.ptp(loc_list, axis=0) / 2
                    self.offset_diff[row, col] = np.around(np.linalg.norm(ptp))
            else:
                stitch_list.append(item)
                # print(&#34;{}:{} no stitch neighbor&#34;.format(row, col))
    # 将最近邻连通域的FOV的位置调整到预测位置
    if nearest_domain_fov is not None:
        nearest_fov_scope_loc = self.scope_global_loc[nearest_domain_fov[0], nearest_domain_fov[1]]
        offset = self.global_loc[nearest_domain_fov[0], nearest_domain_fov[1]] - \
                 self.lr.predict([nearest_fov_scope_loc])[0]
        offset = np.around(offset)
        self.global_loc[np.where(stitch_mask == 1)] -= offset.astype(np.int32)</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_domain_fov"><code class="name flex">
<span>def <span class="ident">get_nearest_domain_fov</span></span>(<span>self, current_domain, stitched_loc)</span>
</code></dt>
<dd>
<div class="desc"><p>获得当前连通域中,离已经拼接的连通域最近的FOV的行列号</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nearest_domain_fov(self, current_domain, stitched_loc):
    &#34;&#34;&#34;获得当前连通域中,离已经拼接的连通域最近的FOV的行列号&#34;&#34;&#34;
    min_distance = 999
    nearst_domain = None
    for fov_loc in current_domain:
        distance, _ = self.get_nearest_points(fov_loc, stitched_loc)
        distance = np.linalg.norm(distance)
        if distance &lt; min_distance:
            min_distance = distance
            nearst_domain = fov_loc
    return nearst_domain, min_distance</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_points"><code class="name flex">
<span>def <span class="ident">get_nearest_points</span></span>(<span>self, input_point, template_points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nearest_points(self, input_point, template_points):
    # 获得最靠近的点
    tree = spt.cKDTree(data=template_points)
    distance, index = tree.query(input_point, k=2)
    neighbor_point = template_points[index[0]]
    distance = np.abs(input_point - neighbor_point)
    return distance, neighbor_point</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_center_2_global_loc"><code class="name flex">
<span>def <span class="ident">multi_center_2_global_loc</span></span>(<span>self, center_start=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_center_2_global_loc(self, center_start=False):
    self.lr = LinearRegression()
    self.lr.fit(np.array([[0, 0]]), np.array([[0, 0]]))
    if (self.lr.coef_ == 0).all():
        self.lr.coef_ = np.diag(np.ones(2))

    for domain_idx in self.domain_list:
        if center_start:
            center_row, center_col = int(self.rows / 2), int(self.cols / 2)
        else:
            center_row, center_col = self.getStitchCenter(max_domain=domain_idx)

        stitch_order = list()
        stitch_order.append((center_row, center_col))
        stitch_list = self._getStitchOrder_by_domain(stitch_order)
        self.get_domain_Loc(self.fov_height, self.fov_width, stitch_list)

        # 训练线性模型
        self.lr.fit(self.scope_global_loc[np.where(self.stitch_masked == 1)],
                    self.global_loc[np.where(self.stitch_masked == 1)])

    # 利用训练好的线性模型, 预测非连通域的fov坐标
    # for row,col in np.vstack(np.where(self.stitch_masked!=1)).T:
    #     self.global_loc[row,col] = self.lr.predict([self.scope_global_loc[row,col]])
    #     self.stitch_masked[row,col] = 1
    self.fix_unstitch_loc()
    self.cumulate_offset = np.max(self.offset_diff)
    # self.save_single_heatmap(self.offset_diff, name=&#34;offset_diff&#34;)

    self.global_loc[:, :, 0] -= np.min(self.global_loc[:, :, 0])
    self.global_loc[:, :, 1] -= np.min(self.global_loc[:, :, 1])</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_connect_domain_center"><code class="name flex">
<span>def <span class="ident">multi_connect_domain_center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>从中心开始拓展出所有拼接顺序
支持外部键入row, col
否则计算最大连通域中心</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_connect_domain_center(self):
    &#39;&#39;&#39;从中心开始拓展出所有拼接顺序
    支持外部键入row, col
    否则计算最大连通域中心
    &#39;&#39;&#39;

    # if row is None and col is None:
    self.caculateDomains()
    max_domain = max(self.connect_domains.values(), key=list(self.connect_domains.values()).count)
    self.domain_list = self.domain_order(max_domain)</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor"><code class="name flex">
<span>def <span class="ident">neighbor</span></span>(<span>self, row, col, mask: numpy.ndarray = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the unstitching FOV of the specified column position attachment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbor(self, row, col, mask: np.ndarray = None):
    &#34;&#34;&#34;
    Gets the unstitching FOV of the specified column position attachment
    &#34;&#34;&#34;
    if (col - 1) &lt; 0:
        left = None
    else:
        left = (row, col - 1)
    if (col + 1) &gt; (self.cols - 1):
        right = None
    else:
        right = (row, col + 1)
    if (row - 1) &lt; 0:
        up = None
    else:
        up = (row - 1, col)
    if (row + 1) &gt; (self.rows - 1):
        down = None
    else:
        down = (row + 1, col)

    if mask is None:
        return [left, right, up, down]
    else:
        mask_list = list()
        for it in [left, right, up, down]:
            if it and mask[it[0], it[1]] == 1:
                mask_list.append(it)
        return mask_list</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor_fix"><code class="name flex">
<span>def <span class="ident">neighbor_fix</span></span>(<span>self, row, col)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the unstitching FOV of the specified column position attachment
:return: [r, c]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbor_fix(self, row, col):
    &#34;&#34;&#34;
    Gets the unstitching FOV of the specified column position attachment
    :return: [r, c]
    &#34;&#34;&#34;
    if (col - 1) &lt; 0:
        left = None
    else:
        left = [row, col - 1]
    if (col + 1) &gt; (self.cols - 1):
        right = None
    else:
        right = [row, col + 1]
    if (row - 1) &lt; 0:
        up = None
    else:
        up = [row - 1, col]
    if (row + 1) &gt; (self.rows - 1):
        down = None
    else:
        down = [row + 1, col]

    for it in [left, right, up, down]:
        if it:
            if self.stitch_masked[it[0], it[1]] == 1:
                return it
    return None</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_fov_size"><code class="name flex">
<span>def <span class="ident">set_fov_size</span></span>(<span>self, fov_height, fov_width)</span>
</code></dt>
<dd>
<div class="desc"><p>set fov size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fov_size(self, fov_height, fov_width):
    &#34;&#34;&#34;set fov size&#34;&#34;&#34;
    self.fov_height = fov_height
    self.fov_width = fov_width</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_jitter"><code class="name flex">
<span>def <span class="ident">set_jitter</span></span>(<span>self, h_j, v_j)</span>
</code></dt>
<dd>
<div class="desc"><p>set jitter matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jitter(self, h_j, v_j):
    &#39;&#39;&#39;set jitter matrix&#39;&#39;&#39;
    assert h_j.shape == v_j.shape, &#34;jitter ndim is diffient&#34;
    self.horizontal_jitter = h_j
    self.vertical_jitter = v_j</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc"><code class="name flex">
<span>def <span class="ident">set_scope_loc</span></span>(<span>self, scope_loc: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>set scope loction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scope_loc(self, scope_loc: np.ndarray):
    &#34;&#34;&#34;set scope loction&#34;&#34;&#34;
    self.scope_global_loc = scope_loc</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc_by_overlap"><code class="name flex">
<span>def <span class="ident">set_scope_loc_by_overlap</span></span>(<span>self, h, w, overlap)</span>
</code></dt>
<dd>
<div class="desc"><p>计算显微镜的原始拼接坐标</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scope_loc_by_overlap(self, h, w, overlap):
    &#34;&#34;&#34;计算显微镜的原始拼接坐标&#34;&#34;&#34;
    scope_global_loc = np.zeros(shape=(self.rows, self.cols, 2), dtype=np.int32)
    self.fov_height = h
    self.fov_width = w
    for i in range(self.rows):
        for j in range(self.cols):
            scope_global_loc[i, j, 0] = j * (w - int(w * overlap))
            scope_global_loc[i, j, 1] = i * (h - int(h * overlap))
    self.scope_global_loc = scope_global_loc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cellbin.contrib.global_location.GlobalLocation"><code class="flex name class">
<span>class <span class="ident">GlobalLocation</span></span>
</code></dt>
<dd>
<div class="desc"><p>只接收偏移量矩阵并求解最终拼接坐标</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobalLocation(object):
    &#34;&#34;&#34;
    只接收偏移量矩阵并求解最终拼接坐标
    &#34;&#34;&#34;
    def __init__(self):
        self.overlap = 0.1
        self.fov_loc_array = None
        self.offset_diff = None
        self.__init_value = 999
        self.horizontal_jitter = None
        self.vertical_jitter = None
        self.fov_height = None
        self.fov_width = None
        self.rows = None
        self.cols = None

    def set_jitter(self, h_j, v_j):
        assert h_j.shape == v_j.shape, &#34;Jitter ndim is diffient.&#34;
        h_j[np.where(h_j == -self.__init_value)] = self.__init_value
        v_j[np.where(v_j == -self.__init_value)] = self.__init_value
        self.horizontal_jitter = h_j
        self.vertical_jitter = v_j

    def set_image_shape(self, height, width):
        assert isinstance(height, int) or isinstance(height, float), &#34;Height type error.&#34;
        assert isinstance(width, int) or isinstance(width, float), &#34;Width type error.&#34;
        self.fov_height = int(height)
        self.fov_width = int(width)

    def set_size(self, rows, cols):
        assert isinstance(rows, int) or isinstance(rows, float), &#34;Rows type error.&#34;
        assert isinstance(cols, int) or isinstance(cols, float), &#34;Cols type error.&#34;
        self.rows = rows
        self.cols = cols

    def create_location(self, mode=&#39;cd&#39;):
        &#34;&#34;&#34;
        :param mode:生成最终坐标 &#39;cd&#39;
        &#34;&#34;&#34;
        if mode == &#39;cd&#39;:
            coord_model = CenterLrDiffuseStitch(self.rows, self.cols)
            coord_model.set_jitter(self.horizontal_jitter, self.vertical_jitter)
            coord_model.set_scope_loc_by_overlap(self.fov_height, self.fov_width, self.overlap)
            coord_model.multi_connect_domain_center()
            coord_model.multi_center_2_global_loc(center_start=False)

            self.offset_diff = coord_model.offset_diff
            self.fov_loc_array = coord_model.global_loc
        else:
            pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cellbin.contrib.global_location.GlobalLocation.create_location"><code class="name flex">
<span>def <span class="ident">create_location</span></span>(<span>self, mode='cd')</span>
</code></dt>
<dd>
<div class="desc"><p>:param mode:生成最终坐标 'cd'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_location(self, mode=&#39;cd&#39;):
    &#34;&#34;&#34;
    :param mode:生成最终坐标 &#39;cd&#39;
    &#34;&#34;&#34;
    if mode == &#39;cd&#39;:
        coord_model = CenterLrDiffuseStitch(self.rows, self.cols)
        coord_model.set_jitter(self.horizontal_jitter, self.vertical_jitter)
        coord_model.set_scope_loc_by_overlap(self.fov_height, self.fov_width, self.overlap)
        coord_model.multi_connect_domain_center()
        coord_model.multi_center_2_global_loc(center_start=False)

        self.offset_diff = coord_model.offset_diff
        self.fov_loc_array = coord_model.global_loc
    else:
        pass</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.GlobalLocation.set_image_shape"><code class="name flex">
<span>def <span class="ident">set_image_shape</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image_shape(self, height, width):
    assert isinstance(height, int) or isinstance(height, float), &#34;Height type error.&#34;
    assert isinstance(width, int) or isinstance(width, float), &#34;Width type error.&#34;
    self.fov_height = int(height)
    self.fov_width = int(width)</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.GlobalLocation.set_jitter"><code class="name flex">
<span>def <span class="ident">set_jitter</span></span>(<span>self, h_j, v_j)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jitter(self, h_j, v_j):
    assert h_j.shape == v_j.shape, &#34;Jitter ndim is diffient.&#34;
    h_j[np.where(h_j == -self.__init_value)] = self.__init_value
    v_j[np.where(v_j == -self.__init_value)] = self.__init_value
    self.horizontal_jitter = h_j
    self.vertical_jitter = v_j</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.global_location.GlobalLocation.set_size"><code class="name flex">
<span>def <span class="ident">set_size</span></span>(<span>self, rows, cols)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_size(self, rows, cols):
    assert isinstance(rows, int) or isinstance(rows, float), &#34;Rows type error.&#34;
    assert isinstance(cols, int) or isinstance(cols, float), &#34;Cols type error.&#34;
    self.rows = rows
    self.cols = cols</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cellbin.contrib" href="index.html">cellbin.contrib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch">CenterLrDiffuseStitch</a></code></h4>
<ul class="">
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateCenter" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateCenter">caculateCenter</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateDomains" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.caculateDomains">caculateDomains</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.centerToGlobal" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.centerToGlobal">centerToGlobal</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.check_feature_matrix" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.check_feature_matrix">check_feature_matrix</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.check_up_stitch" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.check_up_stitch">check_up_stitch</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.domain_order" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.domain_order">domain_order</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.fix_unstitch_loc" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.fix_unstitch_loc">fix_unstitch_loc</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.getLastGlobalLoc" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.getLastGlobalLoc">getLastGlobalLoc</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.getStitchCenter" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.getStitchCenter">getStitchCenter</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_domain_Loc" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.get_domain_Loc">get_domain_Loc</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_domain_fov" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_domain_fov">get_nearest_domain_fov</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_points" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.get_nearest_points">get_nearest_points</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_center_2_global_loc" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_center_2_global_loc">multi_center_2_global_loc</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_connect_domain_center" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.multi_connect_domain_center">multi_connect_domain_center</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor">neighbor</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor_fix" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.neighbor_fix">neighbor_fix</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_fov_size" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.set_fov_size">set_fov_size</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_jitter" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.set_jitter">set_jitter</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc">set_scope_loc</a></code></li>
<li><code><a title="cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc_by_overlap" href="#cellbin.contrib.global_location.CenterLrDiffuseStitch.set_scope_loc_by_overlap">set_scope_loc_by_overlap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cellbin.contrib.global_location.GlobalLocation" href="#cellbin.contrib.global_location.GlobalLocation">GlobalLocation</a></code></h4>
<ul class="">
<li><code><a title="cellbin.contrib.global_location.GlobalLocation.create_location" href="#cellbin.contrib.global_location.GlobalLocation.create_location">create_location</a></code></li>
<li><code><a title="cellbin.contrib.global_location.GlobalLocation.set_image_shape" href="#cellbin.contrib.global_location.GlobalLocation.set_image_shape">set_image_shape</a></code></li>
<li><code><a title="cellbin.contrib.global_location.GlobalLocation.set_jitter" href="#cellbin.contrib.global_location.GlobalLocation.set_jitter">set_jitter</a></code></li>
<li><code><a title="cellbin.contrib.global_location.GlobalLocation.set_size" href="#cellbin.contrib.global_location.GlobalLocation.set_size">set_size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>