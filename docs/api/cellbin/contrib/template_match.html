<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cellbin.contrib.template_match API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cellbin.contrib.template_match</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from copy import copy
import math
import numpy as np

from cellbin.contrib import Line
from cellbin.utils import clog


def intersect(s1, s2, s_idx, template, tolerance=15):
    # 计算匹配程度
    o_itcp = []
    o_idx = []
    tp_tmp = [template[idx] for idx in s_idx]
    i = j = 0
    st = 0
    ed = 0
    err_dist = 0
    while i &lt; len(s1) and j &lt; len(s2):
        if abs(s1[i] - s2[j]) &lt;= tolerance:
            err_dist += abs(s1[i] - s2[j])
            # 如果实际截距和理论截距在容忍范围内认为匹配
            if len(o_itcp) == 0:
                st = i
            o_itcp.append(s2[j])
            o_idx.append(s_idx[i])
            i += 1
            j += 1
            ed = i
        elif s1[i] - s2[j] &lt; 0:
            i += 1
        else:
            # 实际截距中无法匹配的值index置为-1
            o_idx.append(-1)
            j += 1

    if len(o_idx) &lt; len(s2):
        for k in range(len(s2) - len(o_idx)):
            o_idx.append(-1)

    # 通过有效index计算标准模板的总宽度
    if st == ed:
        tp_dist = 0
    else:
        tp_dist = np.sum(tp_tmp[st:ed - 1])

    return o_itcp, o_idx, tp_dist, err_dist


def map_by_intercept(intercept, template, length=2040, scale_min=0.2, scale_max=2.5):
    # 根据index获取模板宽度
    def get_template(idx):
        if idx &lt; 0 or idx &gt;= len(template):
            return template[idx % len(template)]
        else:
            return template[idx]

    # 通过实际截距计算实际宽度
    interval = [(intercept[i + 1] - intercept[i]) for i in range(len(intercept) - 1)]
    # count = len(interval)
    # template_len = len(template)

    # template_used = template * ((math.ceil(count / template_len)) + 2)
    # template_used.extend(template[:count-1])

    index = []
    eff_itcp = []
    tp_dist = 0
    o_score = 0
    err_min = 0
    # 用每一个实际截距和每一个模板宽度进行枚举计算
    for i in range(len(interval)):
        val = interval[i]
        itcp = intercept[i]
        if itcp &lt; 0:
            continue
        for j in range(len(template)):
            fake_itcp = [itcp]
            fake_idx = [j]

            # 计算临时scale
            scale_tmp = val / template[j]
            if scale_tmp &lt; scale_min or scale_tmp &gt; scale_max:
                continue

            # 推算该临时scale下的理论截距列表和对应的index列表
            k = j - 1
            st = itcp - get_template(k) * scale_tmp
            while st &gt;= 0:
                fake_itcp.insert(0, st)
                fake_idx.insert(0, k)
                k -= 1
                st -= get_template(k) * scale_tmp

            k = j
            st = itcp + get_template(k) * scale_tmp
            while st &lt; length:
                fake_itcp.append(st)
                fake_idx.append(k + 1)
                k += 1
                st += get_template(k) * scale_tmp

            for n in range(len(fake_idx)):
                fake_idx[n] = fake_idx[n] % len(template)

            # 计算和判断匹配程度
            o_itcp, o_idx, tmp_dist, err_dist = intersect(fake_itcp, intercept, fake_idx, template)
            if len(o_itcp) &gt; o_score:
                o_score = len(o_itcp)
                index = o_idx
                eff_itcp = o_itcp
                tp_dist = tmp_dist
                err_min = err_dist
            elif len(o_itcp) == o_score:
                if err_dist &lt; err_min:
                    o_score = len(o_itcp)
                    index = o_idx
                    eff_itcp = o_itcp
                    tp_dist = tmp_dist
                    err_min = err_dist

    # 结果过滤和异常处理
    if o_score &lt;= 2:
        return -1, -1, -1, -1
    if tp_dist == 0:
        return -1, -1, -1, -1

    # 计算scale
    im_dist = eff_itcp[-1] - eff_itcp[0]

    scale = im_dist / tp_dist

    return index, scale, o_score, err_min


def template_reassign(index, template, scale):
    tr = []
    for i in range(len(index)):
        if index[i] == -1:
            continue
        dist = template[index[i]]
        try:
            dd = [k &gt;= 0 for k in index[i + 1:]].index(True)
        except:
            dd = -1
        if dd &gt;= 0:
            j = index[i] + 1
            if j &gt;= len(template):
                j = j % len(template)
            while j != index[i + dd + 1]:
                dist += template[j]
                j += 1
                if j &gt;= len(template):
                    j = j % len(template)
        tr.append(dist * scale)
    return tr


def intercept_reassign(x0, intercept_):
    intercept = [x0]
    accumulator = x0
    for i in intercept_:
        accumulator += i
        intercept.append(accumulator)
    return intercept


# TODO: template / cos(angle)???
# TODO: template reassign ?????
class TemplateMatcher(object):
    def __init__(self, magnification, scale_range):
        &#34;&#34;&#34;

        Args:
            scope_type (): 10x or 20x
            scale_range (): scale search range
        &#34;&#34;&#34;
        if magnification == 10:
            self.scale_min = 1 - scale_range
            self.scale_max = 1 + scale_range
        elif magnification == 20:
            self.scale_min = 2 - scale_range
            self.scale_max = 2 + scale_range
        else:
            raise Exception(f&#34;{magnification} not supported&#34;)
        clog.info(f&#34;Using scale min: {self.scale_min}, scale max: {self.scale_max}&#34;)
        self.cross_pts = []
        self.x_scale = -1
        self.y_scale = -1
        self.rotation = None
        self.x_cnt = -1
        self.y_cnt = -1
        self.x_err_min = -1
        self.y_err_min = -1

    def template_match(self, x_intercept, y_intercept, shape, chip_template):
        result = [-1] * 10

        x_template = chip_template[0]
        y_template = chip_template[1]

        if len(x_intercept) == 0 or len(y_intercept) == 0:
            return result

        x_index, x_scale, x_cnt, x_err_min = map_by_intercept(
            x_intercept,
            x_template,
            shape[1],
            scale_min=self.scale_min,
            scale_max=self.scale_max
        )
        y_index, y_scale, y_cnt, y_err_min = map_by_intercept(
            y_intercept,
            y_template,
            shape[0],
            scale_min=self.scale_min,
            scale_max=self.scale_max
        )

        if x_scale &lt; 0 or y_scale &lt; 0 or abs(x_scale / y_scale - 1) &gt; 0.1 or len(x_index) &lt; 2 or len(y_index) &lt; 2:
            return result

        if len(y_index) &lt; len(x_index):
            y_scale += (1 - len(y_index) / len(x_index)) * abs(x_scale - y_scale)
        elif len(y_index) &gt; len(x_index):
            x_scale += (1 - len(x_index) / len(y_index)) * abs(x_scale - y_scale)

        x_i = template_reassign(x_index, x_template, x_scale)
        y_i = template_reassign(y_index, y_template, y_scale)

        x_intercept = [x_intercept[x_] for x_ in range(len(x_intercept)) if x_index[x_] &gt;= 0]
        y_intercept = [y_intercept[y_] for y_ in range(len(y_intercept)) if y_index[y_] &gt;= 0]

        x_intercept_ = intercept_reassign(x_intercept[0], x_i[:-1])
        y_intercept_ = intercept_reassign(y_intercept[0], y_i[:-1])

        result = [
            x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min
        ]

        return result

    def match(
            self,
            shape,
            track_lines,
            chip_template
    ):
        &#34;&#34;&#34;
        What this function do?
        Given the track line of the image, this algo will match all possible track lines. This algo will get scale and
        rotation based on the possible track lines. After that, this algo will regenerate x and y intercept based on the
        first line in each direction and the corresponding scale.

        Args:
            shape (): shape of the image
            track_lines (): track line of the image
            chip_template ():  the template of the chip

        Results:
            self.cross_pts: list of list (success) -&gt; [[x, y, x_ind, y_ind], ...], None (fail)
            self.x_scale: float (success), None (fail)
            self.y_scale: float (success), None (fail)
            self.rotation: float (success), None (fail)

        Return:
            0: success
            1: fail

        &#34;&#34;&#34;
        self.cross_pts = []
        self.x_scale = -1
        self.y_scale = -1
        self.rotation = None
        self.x_cnt = -1
        self.y_cnt = -1
        self.x_err_min = -1
        self.y_err_min = -1

        k = list()
        x_intercept = list()
        y_intercept = list()
        counter = 0
        for line in track_lines:
            if abs(line.coefficient) &lt;= 1:
                k.append(line.coefficient)
                y_intercept.append([line.bias, counter])
                counter += 1
            else:
                k.append(-1 / line.coefficient)
                x_intercept.append([line.get_point_by_y(0)[0], counter])
                counter += 1
        x_intercept.sort()
        y_intercept.sort()

        x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min = \
            self.template_match(
                [val[0] for val in x_intercept],
                [val[0] for val in y_intercept],
                shape,
                chip_template
        )

        if x_intercept_ == -1:
            return 1

        templx_lines = list()
        temply_lines = list()
        line = Line()

        strip = []
        for i in range(len(x_index)):
            if x_index[i] == -1:
                strip.append(x_intercept[i][1])
        for j in range(len(y_index)):
            if y_index[j] == -1:
                strip.append(y_intercept[j][1])

        k = [k[i] for i in range(len(k)) if i not in strip]

        coeff = np.mean(k)
        rotation = math.degrees(math.atan(coeff))

        x_scale = x_scale * math.cos(math.radians(rotation))
        y_scale = y_scale * math.cos(math.radians(rotation))

        x_index = [x for x in x_index if x &gt;= 0]
        y_index = [y for y in y_index if y &gt;= 0]

        for i in range(len(x_intercept_)):
            x = x_intercept_[i]
            line.init_by_point_k([x, 0], -1 / coeff)
            line.index = x_index[i]
            templx_lines.append(copy(line))
        for j in range(len(y_intercept_)):
            y = y_intercept_[j]
            line.init_by_point_k([0, y], coeff)
            line.index = y_index[j]
            temply_lines.append(copy(line))
        templ_points = self.make_cross_points(
            templx_lines=templx_lines,
            temply_lines=temply_lines
        )
        cross_pts = self.point_spread_into_template(
            templ_points=templ_points,
            rotation=rotation,
            shape=shape,
            chip_template=chip_template,
            x_scale=x_scale,
            y_scale=y_scale
        )

        self.cross_pts = cross_pts
        self.x_scale = x_scale
        self.y_scale = y_scale
        self.rotation = rotation
        self.x_cnt = x_cnt
        self.y_cnt = y_cnt
        self.x_err_min = x_err_min
        self.y_err_min = y_err_min

        return 0

    def point_spread_into_template(
            self,
            templ_points,
            rotation,
            shape,
            chip_template,
            x_scale,
            y_scale,
    ):
        x, y, ind_x, ind_y = templ_points[0]
        k0 = math.tan(math.radians(rotation))
        if k0 == 0:
            k0 = 0.00000001
        k1 = -1 / k0
        x0, y0 = 0, 0
        x0 += x
        y0 += y

        y_intercept0 = y0 - k0 * x0
        x_intercept0 = (y0 - k1 * x0) * k0

        dy = abs(k0 * shape[1])
        y_region = (-dy, shape[0] + dy)
        dx = abs(k0 * shape[0])
        x_region = (-dx, shape[1] + dx)
        y_intercept = self.get_intercept(y_intercept0, y_region, ind_y, chip_template[1], y_scale, rotation)
        x_intercept = self.get_intercept(x_intercept0, x_region, ind_x, chip_template[0], x_scale, rotation)
        cross_pts = self.create_cross_points(k0, x_intercept, y_intercept, shape)
        return cross_pts

    def get_intercept(self, intercept0, region, ind, templ, scale, rotation):
        item_count = len(templ)
        idx = intercept0
        intercept = [[idx, ind]]
        s, e = region
        # face to large
        while idx &lt; e:
            ind = ind % item_count
            item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
            idx += item_len
            intercept.append([idx, (ind + 1) % item_count])
            ind += 1
        # face to small
        idx, ind = intercept[0]
        while idx &gt; s:
            ind -= 1
            ind = ind % item_count
            item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
            idx -= item_len
            intercept.append([idx, ind])
        return sorted(intercept, key=(lambda x: x[0]))

    def create_cross_points(self, k, x_intercept, y_intercept, shape):
        cross_points = list()
        for x_ in x_intercept:
            for y_ in y_intercept:
                x, ind_x = x_
                y, ind_y = y_
                x0 = (x - k * y) / (pow(k, 2) + 1)
                y0 = k * x0 + y
                if x0 &lt; 0 or x0 &gt; shape[1] or y0 &lt; 0 or y0 &gt; shape[0]:
                    continue
                cross_points.append([x0, y0, ind_x, ind_y])
        return cross_points

    def make_cross_points(self, templx_lines, temply_lines):
        templ_points = list()
        for yl in temply_lines:
            for xl in templx_lines:
                index_y = yl.index
                index_x = xl.index
                y = yl.bias
                k = yl.coefficient
                x = xl.get_point_by_y(0)[0]
                x0 = (x - k * y) / (pow(k, 2) + 1)
                y0 = k * x0 + y
                templ_points.append([x0, y0, index_x, index_y])
        return templ_points


def main():
    import cv2
    from cellbin.contrib.line_detector import TrackLineDetector
    image_path = r&#34;D:\Data\tmp\Y00035MD\Y00035MD\Y00035MD_0000_0005_2023-01-30_15-50-42-418.tif&#34;
    # image_path = r&#34;D:\Data\tmp\Y00035MD\Y00035MD\Y00035MD_0002_0005_2023-01-30_15-50-52-553.tif&#34;
    arr = cv2.imread(image_path, -1)
    # arr = cv.medianBlur(arr, 3)
    print(arr.shape)
    ftl = TrackLineDetector()
    output_path = None
    angle = None
    image_name = None
    h_lines, v_lines = ftl.generate(
        arr=arr,
    )
    track_lines = h_lines + v_lines
    tm = TemplateMatcher()
    chip_template = [[240, 300, 330, 390, 390, 330, 300, 240, 420],
                     [240, 300, 330, 390, 390, 330, 300, 240, 420]]
    ret = tm.match(
        shape=arr.shape,
        track_lines=track_lines,
        chip_template=chip_template
    )

    print(ret)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cellbin.contrib.template_match.intercept_reassign"><code class="name flex">
<span>def <span class="ident">intercept_reassign</span></span>(<span>x0, intercept_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intercept_reassign(x0, intercept_):
    intercept = [x0]
    accumulator = x0
    for i in intercept_:
        accumulator += i
        intercept.append(accumulator)
    return intercept</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>s1, s2, s_idx, template, tolerance=15)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect(s1, s2, s_idx, template, tolerance=15):
    # 计算匹配程度
    o_itcp = []
    o_idx = []
    tp_tmp = [template[idx] for idx in s_idx]
    i = j = 0
    st = 0
    ed = 0
    err_dist = 0
    while i &lt; len(s1) and j &lt; len(s2):
        if abs(s1[i] - s2[j]) &lt;= tolerance:
            err_dist += abs(s1[i] - s2[j])
            # 如果实际截距和理论截距在容忍范围内认为匹配
            if len(o_itcp) == 0:
                st = i
            o_itcp.append(s2[j])
            o_idx.append(s_idx[i])
            i += 1
            j += 1
            ed = i
        elif s1[i] - s2[j] &lt; 0:
            i += 1
        else:
            # 实际截距中无法匹配的值index置为-1
            o_idx.append(-1)
            j += 1

    if len(o_idx) &lt; len(s2):
        for k in range(len(s2) - len(o_idx)):
            o_idx.append(-1)

    # 通过有效index计算标准模板的总宽度
    if st == ed:
        tp_dist = 0
    else:
        tp_dist = np.sum(tp_tmp[st:ed - 1])

    return o_itcp, o_idx, tp_dist, err_dist</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    import cv2
    from cellbin.contrib.line_detector import TrackLineDetector
    image_path = r&#34;D:\Data\tmp\Y00035MD\Y00035MD\Y00035MD_0000_0005_2023-01-30_15-50-42-418.tif&#34;
    # image_path = r&#34;D:\Data\tmp\Y00035MD\Y00035MD\Y00035MD_0002_0005_2023-01-30_15-50-52-553.tif&#34;
    arr = cv2.imread(image_path, -1)
    # arr = cv.medianBlur(arr, 3)
    print(arr.shape)
    ftl = TrackLineDetector()
    output_path = None
    angle = None
    image_name = None
    h_lines, v_lines = ftl.generate(
        arr=arr,
    )
    track_lines = h_lines + v_lines
    tm = TemplateMatcher()
    chip_template = [[240, 300, 330, 390, 390, 330, 300, 240, 420],
                     [240, 300, 330, 390, 390, 330, 300, 240, 420]]
    ret = tm.match(
        shape=arr.shape,
        track_lines=track_lines,
        chip_template=chip_template
    )

    print(ret)</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.map_by_intercept"><code class="name flex">
<span>def <span class="ident">map_by_intercept</span></span>(<span>intercept, template, length=2040, scale_min=0.2, scale_max=2.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_by_intercept(intercept, template, length=2040, scale_min=0.2, scale_max=2.5):
    # 根据index获取模板宽度
    def get_template(idx):
        if idx &lt; 0 or idx &gt;= len(template):
            return template[idx % len(template)]
        else:
            return template[idx]

    # 通过实际截距计算实际宽度
    interval = [(intercept[i + 1] - intercept[i]) for i in range(len(intercept) - 1)]
    # count = len(interval)
    # template_len = len(template)

    # template_used = template * ((math.ceil(count / template_len)) + 2)
    # template_used.extend(template[:count-1])

    index = []
    eff_itcp = []
    tp_dist = 0
    o_score = 0
    err_min = 0
    # 用每一个实际截距和每一个模板宽度进行枚举计算
    for i in range(len(interval)):
        val = interval[i]
        itcp = intercept[i]
        if itcp &lt; 0:
            continue
        for j in range(len(template)):
            fake_itcp = [itcp]
            fake_idx = [j]

            # 计算临时scale
            scale_tmp = val / template[j]
            if scale_tmp &lt; scale_min or scale_tmp &gt; scale_max:
                continue

            # 推算该临时scale下的理论截距列表和对应的index列表
            k = j - 1
            st = itcp - get_template(k) * scale_tmp
            while st &gt;= 0:
                fake_itcp.insert(0, st)
                fake_idx.insert(0, k)
                k -= 1
                st -= get_template(k) * scale_tmp

            k = j
            st = itcp + get_template(k) * scale_tmp
            while st &lt; length:
                fake_itcp.append(st)
                fake_idx.append(k + 1)
                k += 1
                st += get_template(k) * scale_tmp

            for n in range(len(fake_idx)):
                fake_idx[n] = fake_idx[n] % len(template)

            # 计算和判断匹配程度
            o_itcp, o_idx, tmp_dist, err_dist = intersect(fake_itcp, intercept, fake_idx, template)
            if len(o_itcp) &gt; o_score:
                o_score = len(o_itcp)
                index = o_idx
                eff_itcp = o_itcp
                tp_dist = tmp_dist
                err_min = err_dist
            elif len(o_itcp) == o_score:
                if err_dist &lt; err_min:
                    o_score = len(o_itcp)
                    index = o_idx
                    eff_itcp = o_itcp
                    tp_dist = tmp_dist
                    err_min = err_dist

    # 结果过滤和异常处理
    if o_score &lt;= 2:
        return -1, -1, -1, -1
    if tp_dist == 0:
        return -1, -1, -1, -1

    # 计算scale
    im_dist = eff_itcp[-1] - eff_itcp[0]

    scale = im_dist / tp_dist

    return index, scale, o_score, err_min</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.template_reassign"><code class="name flex">
<span>def <span class="ident">template_reassign</span></span>(<span>index, template, scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def template_reassign(index, template, scale):
    tr = []
    for i in range(len(index)):
        if index[i] == -1:
            continue
        dist = template[index[i]]
        try:
            dd = [k &gt;= 0 for k in index[i + 1:]].index(True)
        except:
            dd = -1
        if dd &gt;= 0:
            j = index[i] + 1
            if j &gt;= len(template):
                j = j % len(template)
            while j != index[i + dd + 1]:
                dist += template[j]
                j += 1
                if j &gt;= len(template):
                    j = j % len(template)
        tr.append(dist * scale)
    return tr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cellbin.contrib.template_match.TemplateMatcher"><code class="flex name class">
<span>class <span class="ident">TemplateMatcher</span></span>
<span>(</span><span>magnification, scale_range)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>scope_type (): 10x or 20x
scale_range (): scale search range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TemplateMatcher(object):
    def __init__(self, magnification, scale_range):
        &#34;&#34;&#34;

        Args:
            scope_type (): 10x or 20x
            scale_range (): scale search range
        &#34;&#34;&#34;
        if magnification == 10:
            self.scale_min = 1 - scale_range
            self.scale_max = 1 + scale_range
        elif magnification == 20:
            self.scale_min = 2 - scale_range
            self.scale_max = 2 + scale_range
        else:
            raise Exception(f&#34;{magnification} not supported&#34;)
        clog.info(f&#34;Using scale min: {self.scale_min}, scale max: {self.scale_max}&#34;)
        self.cross_pts = []
        self.x_scale = -1
        self.y_scale = -1
        self.rotation = None
        self.x_cnt = -1
        self.y_cnt = -1
        self.x_err_min = -1
        self.y_err_min = -1

    def template_match(self, x_intercept, y_intercept, shape, chip_template):
        result = [-1] * 10

        x_template = chip_template[0]
        y_template = chip_template[1]

        if len(x_intercept) == 0 or len(y_intercept) == 0:
            return result

        x_index, x_scale, x_cnt, x_err_min = map_by_intercept(
            x_intercept,
            x_template,
            shape[1],
            scale_min=self.scale_min,
            scale_max=self.scale_max
        )
        y_index, y_scale, y_cnt, y_err_min = map_by_intercept(
            y_intercept,
            y_template,
            shape[0],
            scale_min=self.scale_min,
            scale_max=self.scale_max
        )

        if x_scale &lt; 0 or y_scale &lt; 0 or abs(x_scale / y_scale - 1) &gt; 0.1 or len(x_index) &lt; 2 or len(y_index) &lt; 2:
            return result

        if len(y_index) &lt; len(x_index):
            y_scale += (1 - len(y_index) / len(x_index)) * abs(x_scale - y_scale)
        elif len(y_index) &gt; len(x_index):
            x_scale += (1 - len(x_index) / len(y_index)) * abs(x_scale - y_scale)

        x_i = template_reassign(x_index, x_template, x_scale)
        y_i = template_reassign(y_index, y_template, y_scale)

        x_intercept = [x_intercept[x_] for x_ in range(len(x_intercept)) if x_index[x_] &gt;= 0]
        y_intercept = [y_intercept[y_] for y_ in range(len(y_intercept)) if y_index[y_] &gt;= 0]

        x_intercept_ = intercept_reassign(x_intercept[0], x_i[:-1])
        y_intercept_ = intercept_reassign(y_intercept[0], y_i[:-1])

        result = [
            x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min
        ]

        return result

    def match(
            self,
            shape,
            track_lines,
            chip_template
    ):
        &#34;&#34;&#34;
        What this function do?
        Given the track line of the image, this algo will match all possible track lines. This algo will get scale and
        rotation based on the possible track lines. After that, this algo will regenerate x and y intercept based on the
        first line in each direction and the corresponding scale.

        Args:
            shape (): shape of the image
            track_lines (): track line of the image
            chip_template ():  the template of the chip

        Results:
            self.cross_pts: list of list (success) -&gt; [[x, y, x_ind, y_ind], ...], None (fail)
            self.x_scale: float (success), None (fail)
            self.y_scale: float (success), None (fail)
            self.rotation: float (success), None (fail)

        Return:
            0: success
            1: fail

        &#34;&#34;&#34;
        self.cross_pts = []
        self.x_scale = -1
        self.y_scale = -1
        self.rotation = None
        self.x_cnt = -1
        self.y_cnt = -1
        self.x_err_min = -1
        self.y_err_min = -1

        k = list()
        x_intercept = list()
        y_intercept = list()
        counter = 0
        for line in track_lines:
            if abs(line.coefficient) &lt;= 1:
                k.append(line.coefficient)
                y_intercept.append([line.bias, counter])
                counter += 1
            else:
                k.append(-1 / line.coefficient)
                x_intercept.append([line.get_point_by_y(0)[0], counter])
                counter += 1
        x_intercept.sort()
        y_intercept.sort()

        x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min = \
            self.template_match(
                [val[0] for val in x_intercept],
                [val[0] for val in y_intercept],
                shape,
                chip_template
        )

        if x_intercept_ == -1:
            return 1

        templx_lines = list()
        temply_lines = list()
        line = Line()

        strip = []
        for i in range(len(x_index)):
            if x_index[i] == -1:
                strip.append(x_intercept[i][1])
        for j in range(len(y_index)):
            if y_index[j] == -1:
                strip.append(y_intercept[j][1])

        k = [k[i] for i in range(len(k)) if i not in strip]

        coeff = np.mean(k)
        rotation = math.degrees(math.atan(coeff))

        x_scale = x_scale * math.cos(math.radians(rotation))
        y_scale = y_scale * math.cos(math.radians(rotation))

        x_index = [x for x in x_index if x &gt;= 0]
        y_index = [y for y in y_index if y &gt;= 0]

        for i in range(len(x_intercept_)):
            x = x_intercept_[i]
            line.init_by_point_k([x, 0], -1 / coeff)
            line.index = x_index[i]
            templx_lines.append(copy(line))
        for j in range(len(y_intercept_)):
            y = y_intercept_[j]
            line.init_by_point_k([0, y], coeff)
            line.index = y_index[j]
            temply_lines.append(copy(line))
        templ_points = self.make_cross_points(
            templx_lines=templx_lines,
            temply_lines=temply_lines
        )
        cross_pts = self.point_spread_into_template(
            templ_points=templ_points,
            rotation=rotation,
            shape=shape,
            chip_template=chip_template,
            x_scale=x_scale,
            y_scale=y_scale
        )

        self.cross_pts = cross_pts
        self.x_scale = x_scale
        self.y_scale = y_scale
        self.rotation = rotation
        self.x_cnt = x_cnt
        self.y_cnt = y_cnt
        self.x_err_min = x_err_min
        self.y_err_min = y_err_min

        return 0

    def point_spread_into_template(
            self,
            templ_points,
            rotation,
            shape,
            chip_template,
            x_scale,
            y_scale,
    ):
        x, y, ind_x, ind_y = templ_points[0]
        k0 = math.tan(math.radians(rotation))
        if k0 == 0:
            k0 = 0.00000001
        k1 = -1 / k0
        x0, y0 = 0, 0
        x0 += x
        y0 += y

        y_intercept0 = y0 - k0 * x0
        x_intercept0 = (y0 - k1 * x0) * k0

        dy = abs(k0 * shape[1])
        y_region = (-dy, shape[0] + dy)
        dx = abs(k0 * shape[0])
        x_region = (-dx, shape[1] + dx)
        y_intercept = self.get_intercept(y_intercept0, y_region, ind_y, chip_template[1], y_scale, rotation)
        x_intercept = self.get_intercept(x_intercept0, x_region, ind_x, chip_template[0], x_scale, rotation)
        cross_pts = self.create_cross_points(k0, x_intercept, y_intercept, shape)
        return cross_pts

    def get_intercept(self, intercept0, region, ind, templ, scale, rotation):
        item_count = len(templ)
        idx = intercept0
        intercept = [[idx, ind]]
        s, e = region
        # face to large
        while idx &lt; e:
            ind = ind % item_count
            item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
            idx += item_len
            intercept.append([idx, (ind + 1) % item_count])
            ind += 1
        # face to small
        idx, ind = intercept[0]
        while idx &gt; s:
            ind -= 1
            ind = ind % item_count
            item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
            idx -= item_len
            intercept.append([idx, ind])
        return sorted(intercept, key=(lambda x: x[0]))

    def create_cross_points(self, k, x_intercept, y_intercept, shape):
        cross_points = list()
        for x_ in x_intercept:
            for y_ in y_intercept:
                x, ind_x = x_
                y, ind_y = y_
                x0 = (x - k * y) / (pow(k, 2) + 1)
                y0 = k * x0 + y
                if x0 &lt; 0 or x0 &gt; shape[1] or y0 &lt; 0 or y0 &gt; shape[0]:
                    continue
                cross_points.append([x0, y0, ind_x, ind_y])
        return cross_points

    def make_cross_points(self, templx_lines, temply_lines):
        templ_points = list()
        for yl in temply_lines:
            for xl in templx_lines:
                index_y = yl.index
                index_x = xl.index
                y = yl.bias
                k = yl.coefficient
                x = xl.get_point_by_y(0)[0]
                x0 = (x - k * y) / (pow(k, 2) + 1)
                y0 = k * x0 + y
                templ_points.append([x0, y0, index_x, index_y])
        return templ_points</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cellbin.contrib.template_match.TemplateMatcher.create_cross_points"><code class="name flex">
<span>def <span class="ident">create_cross_points</span></span>(<span>self, k, x_intercept, y_intercept, shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cross_points(self, k, x_intercept, y_intercept, shape):
    cross_points = list()
    for x_ in x_intercept:
        for y_ in y_intercept:
            x, ind_x = x_
            y, ind_y = y_
            x0 = (x - k * y) / (pow(k, 2) + 1)
            y0 = k * x0 + y
            if x0 &lt; 0 or x0 &gt; shape[1] or y0 &lt; 0 or y0 &gt; shape[0]:
                continue
            cross_points.append([x0, y0, ind_x, ind_y])
    return cross_points</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.TemplateMatcher.get_intercept"><code class="name flex">
<span>def <span class="ident">get_intercept</span></span>(<span>self, intercept0, region, ind, templ, scale, rotation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intercept(self, intercept0, region, ind, templ, scale, rotation):
    item_count = len(templ)
    idx = intercept0
    intercept = [[idx, ind]]
    s, e = region
    # face to large
    while idx &lt; e:
        ind = ind % item_count
        item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
        idx += item_len
        intercept.append([idx, (ind + 1) % item_count])
        ind += 1
    # face to small
    idx, ind = intercept[0]
    while idx &gt; s:
        ind -= 1
        ind = ind % item_count
        item_len = (templ[ind] * scale) / math.cos(math.radians(rotation))
        idx -= item_len
        intercept.append([idx, ind])
    return sorted(intercept, key=(lambda x: x[0]))</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.TemplateMatcher.make_cross_points"><code class="name flex">
<span>def <span class="ident">make_cross_points</span></span>(<span>self, templx_lines, temply_lines)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_cross_points(self, templx_lines, temply_lines):
    templ_points = list()
    for yl in temply_lines:
        for xl in templx_lines:
            index_y = yl.index
            index_x = xl.index
            y = yl.bias
            k = yl.coefficient
            x = xl.get_point_by_y(0)[0]
            x0 = (x - k * y) / (pow(k, 2) + 1)
            y0 = k * x0 + y
            templ_points.append([x0, y0, index_x, index_y])
    return templ_points</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.TemplateMatcher.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, shape, track_lines, chip_template)</span>
</code></dt>
<dd>
<div class="desc"><p>What this function do?
Given the track line of the image, this algo will match all possible track lines. This algo will get scale and
rotation based on the possible track lines. After that, this algo will regenerate x and y intercept based on the
first line in each direction and the corresponding scale.</p>
<h2 id="args">Args</h2>
<p>shape (): shape of the image
track_lines (): track line of the image
chip_template ():
the template of the chip</p>
<h2 id="results">Results</h2>
<p>self.cross_pts: list of list (success) -&gt; [[x, y, x_ind, y_ind], &hellip;], None (fail)
self.x_scale: float (success), None (fail)
self.y_scale: float (success), None (fail)
self.rotation: float (success), None (fail)</p>
<h2 id="return">Return</h2>
<p>0: success
1: fail</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(
        self,
        shape,
        track_lines,
        chip_template
):
    &#34;&#34;&#34;
    What this function do?
    Given the track line of the image, this algo will match all possible track lines. This algo will get scale and
    rotation based on the possible track lines. After that, this algo will regenerate x and y intercept based on the
    first line in each direction and the corresponding scale.

    Args:
        shape (): shape of the image
        track_lines (): track line of the image
        chip_template ():  the template of the chip

    Results:
        self.cross_pts: list of list (success) -&gt; [[x, y, x_ind, y_ind], ...], None (fail)
        self.x_scale: float (success), None (fail)
        self.y_scale: float (success), None (fail)
        self.rotation: float (success), None (fail)

    Return:
        0: success
        1: fail

    &#34;&#34;&#34;
    self.cross_pts = []
    self.x_scale = -1
    self.y_scale = -1
    self.rotation = None
    self.x_cnt = -1
    self.y_cnt = -1
    self.x_err_min = -1
    self.y_err_min = -1

    k = list()
    x_intercept = list()
    y_intercept = list()
    counter = 0
    for line in track_lines:
        if abs(line.coefficient) &lt;= 1:
            k.append(line.coefficient)
            y_intercept.append([line.bias, counter])
            counter += 1
        else:
            k.append(-1 / line.coefficient)
            x_intercept.append([line.get_point_by_y(0)[0], counter])
            counter += 1
    x_intercept.sort()
    y_intercept.sort()

    x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min = \
        self.template_match(
            [val[0] for val in x_intercept],
            [val[0] for val in y_intercept],
            shape,
            chip_template
    )

    if x_intercept_ == -1:
        return 1

    templx_lines = list()
    temply_lines = list()
    line = Line()

    strip = []
    for i in range(len(x_index)):
        if x_index[i] == -1:
            strip.append(x_intercept[i][1])
    for j in range(len(y_index)):
        if y_index[j] == -1:
            strip.append(y_intercept[j][1])

    k = [k[i] for i in range(len(k)) if i not in strip]

    coeff = np.mean(k)
    rotation = math.degrees(math.atan(coeff))

    x_scale = x_scale * math.cos(math.radians(rotation))
    y_scale = y_scale * math.cos(math.radians(rotation))

    x_index = [x for x in x_index if x &gt;= 0]
    y_index = [y for y in y_index if y &gt;= 0]

    for i in range(len(x_intercept_)):
        x = x_intercept_[i]
        line.init_by_point_k([x, 0], -1 / coeff)
        line.index = x_index[i]
        templx_lines.append(copy(line))
    for j in range(len(y_intercept_)):
        y = y_intercept_[j]
        line.init_by_point_k([0, y], coeff)
        line.index = y_index[j]
        temply_lines.append(copy(line))
    templ_points = self.make_cross_points(
        templx_lines=templx_lines,
        temply_lines=temply_lines
    )
    cross_pts = self.point_spread_into_template(
        templ_points=templ_points,
        rotation=rotation,
        shape=shape,
        chip_template=chip_template,
        x_scale=x_scale,
        y_scale=y_scale
    )

    self.cross_pts = cross_pts
    self.x_scale = x_scale
    self.y_scale = y_scale
    self.rotation = rotation
    self.x_cnt = x_cnt
    self.y_cnt = y_cnt
    self.x_err_min = x_err_min
    self.y_err_min = y_err_min

    return 0</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.TemplateMatcher.point_spread_into_template"><code class="name flex">
<span>def <span class="ident">point_spread_into_template</span></span>(<span>self, templ_points, rotation, shape, chip_template, x_scale, y_scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_spread_into_template(
        self,
        templ_points,
        rotation,
        shape,
        chip_template,
        x_scale,
        y_scale,
):
    x, y, ind_x, ind_y = templ_points[0]
    k0 = math.tan(math.radians(rotation))
    if k0 == 0:
        k0 = 0.00000001
    k1 = -1 / k0
    x0, y0 = 0, 0
    x0 += x
    y0 += y

    y_intercept0 = y0 - k0 * x0
    x_intercept0 = (y0 - k1 * x0) * k0

    dy = abs(k0 * shape[1])
    y_region = (-dy, shape[0] + dy)
    dx = abs(k0 * shape[0])
    x_region = (-dx, shape[1] + dx)
    y_intercept = self.get_intercept(y_intercept0, y_region, ind_y, chip_template[1], y_scale, rotation)
    x_intercept = self.get_intercept(x_intercept0, x_region, ind_x, chip_template[0], x_scale, rotation)
    cross_pts = self.create_cross_points(k0, x_intercept, y_intercept, shape)
    return cross_pts</code></pre>
</details>
</dd>
<dt id="cellbin.contrib.template_match.TemplateMatcher.template_match"><code class="name flex">
<span>def <span class="ident">template_match</span></span>(<span>self, x_intercept, y_intercept, shape, chip_template)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def template_match(self, x_intercept, y_intercept, shape, chip_template):
    result = [-1] * 10

    x_template = chip_template[0]
    y_template = chip_template[1]

    if len(x_intercept) == 0 or len(y_intercept) == 0:
        return result

    x_index, x_scale, x_cnt, x_err_min = map_by_intercept(
        x_intercept,
        x_template,
        shape[1],
        scale_min=self.scale_min,
        scale_max=self.scale_max
    )
    y_index, y_scale, y_cnt, y_err_min = map_by_intercept(
        y_intercept,
        y_template,
        shape[0],
        scale_min=self.scale_min,
        scale_max=self.scale_max
    )

    if x_scale &lt; 0 or y_scale &lt; 0 or abs(x_scale / y_scale - 1) &gt; 0.1 or len(x_index) &lt; 2 or len(y_index) &lt; 2:
        return result

    if len(y_index) &lt; len(x_index):
        y_scale += (1 - len(y_index) / len(x_index)) * abs(x_scale - y_scale)
    elif len(y_index) &gt; len(x_index):
        x_scale += (1 - len(x_index) / len(y_index)) * abs(x_scale - y_scale)

    x_i = template_reassign(x_index, x_template, x_scale)
    y_i = template_reassign(y_index, y_template, y_scale)

    x_intercept = [x_intercept[x_] for x_ in range(len(x_intercept)) if x_index[x_] &gt;= 0]
    y_intercept = [y_intercept[y_] for y_ in range(len(y_intercept)) if y_index[y_] &gt;= 0]

    x_intercept_ = intercept_reassign(x_intercept[0], x_i[:-1])
    y_intercept_ = intercept_reassign(y_intercept[0], y_i[:-1])

    result = [
        x_intercept_, y_intercept_, x_index, y_index, x_scale, y_scale, x_cnt, y_cnt, x_err_min, y_err_min
    ]

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cellbin.contrib" href="index.html">cellbin.contrib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cellbin.contrib.template_match.intercept_reassign" href="#cellbin.contrib.template_match.intercept_reassign">intercept_reassign</a></code></li>
<li><code><a title="cellbin.contrib.template_match.intersect" href="#cellbin.contrib.template_match.intersect">intersect</a></code></li>
<li><code><a title="cellbin.contrib.template_match.main" href="#cellbin.contrib.template_match.main">main</a></code></li>
<li><code><a title="cellbin.contrib.template_match.map_by_intercept" href="#cellbin.contrib.template_match.map_by_intercept">map_by_intercept</a></code></li>
<li><code><a title="cellbin.contrib.template_match.template_reassign" href="#cellbin.contrib.template_match.template_reassign">template_reassign</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cellbin.contrib.template_match.TemplateMatcher" href="#cellbin.contrib.template_match.TemplateMatcher">TemplateMatcher</a></code></h4>
<ul class="">
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.create_cross_points" href="#cellbin.contrib.template_match.TemplateMatcher.create_cross_points">create_cross_points</a></code></li>
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.get_intercept" href="#cellbin.contrib.template_match.TemplateMatcher.get_intercept">get_intercept</a></code></li>
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.make_cross_points" href="#cellbin.contrib.template_match.TemplateMatcher.make_cross_points">make_cross_points</a></code></li>
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.match" href="#cellbin.contrib.template_match.TemplateMatcher.match">match</a></code></li>
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.point_spread_into_template" href="#cellbin.contrib.template_match.TemplateMatcher.point_spread_into_template">point_spread_into_template</a></code></li>
<li><code><a title="cellbin.contrib.template_match.TemplateMatcher.template_match" href="#cellbin.contrib.template_match.TemplateMatcher.template_match">template_match</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>