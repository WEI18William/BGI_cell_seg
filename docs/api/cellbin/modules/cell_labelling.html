<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cellbin.modules.cell_labelling API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cellbin.modules.cell_labelling</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import cv2
import numpy as np
import pandas as pd

from stio.matrix_loader import MatrixLoader  # input is file path
from cellbin.contrib.fast_correct import Fast
from cellbin.contrib.GMM_correct import GMM
from cellbin.modules import CellBinElement
from cellbin.utils import clog


class CellLabelling(CellBinElement):
    def __init__(self, mask, gene_file):
        self.mask = None
        self.fast_mask = None
        self.gem = gene_file
        self.bgef = None
        self.cgef = None
        self.exp_matrix = None
        self.process = 8

        self.set_mask(mask)
        # self.set_gem(gene_file)
        # self.set_matrix()

    def set_process(self, p):
        self.process = p

    def run_fast(self, distance=10):
        f = Fast(self.mask, distance, self.process)
        f.process()
        self.set_fast_mask(f.mask)
        self.set_gem(self.gem)
        self.set_matrix()
        return f.mask, self.exp_matrix

    def run_gmm(self, threshold=20, process=10):
        g = GMM(self.exp_matrix, threshold, process)
        g.cell_correct()
        return None, g.gmm_result

    def set_mask(self, mask):
        try:
            # self.mask = tifi.imread(mask)
            self.mask = mask
            self.mask[self.mask &gt; 0] = 1
            self.mask = self.mask.astype(np.uint8)
        except:
            clog.error(f&#39;unable to load cell mask {mask}!&#39;)

    def set_fast_mask(self, mask):
        try:
            self.fast_mask = mask
            self.fast_mask[self.fast_mask &gt; 0] = 1
            self.fast_mask = self.fast_mask.astype(np.uint8)
        except:
            clog.error(f&#39;unable to load cell mask {mask}!&#39;)

    def set_gem(self, gene_file, new_file=&#39;temp.gem&#39;):
        # if gene_file.lower().endswith((&#39;.bgef&#39;, &#39;.gef&#39;)):
        #     from gefpy.bgef_reader_cy import BgefR
        #     self.bgef = BgefR(gene_file, 1, 8)
        #     ml = MatrixLoader(gene_file)
        #     ml.bgef2gem(bgef_file=gene_file, gem_file=new_file, binsize=1)
        #     self.gem = pd.read_csv(new_file, sep=&#39;\t&#39;, skiprows=6)
        # else:
        def row(gem_path):
            if gem_path.endswith(&#39;.gz&#39;):
                import gzip
                with gzip.open(gem_path, &#39;rb&#39;) as f:
                    first_line = bytes.decode(f.readline())
                    if &#39;#&#39; in first_line:
                        rows = 6
                    else:
                        rows = 0
            else:
                with open(gem_path, &#39;rb&#39;) as f:
                    first_line = bytes.decode(f.readline())
                    if &#39;#&#39; in first_line:
                        rows = 6
                    else:
                        rows = 0
            return rows

        self.gem = pd.read_csv(gene_file, sep=&#39;\t&#39;, skiprows=row(gene_file))
        # else:
        #     self.gem = None

    def draw_ori_mask(self, output_path):
        self.mask[self.mask &gt; 0] = 255
        cv2.imwrite(os.path.join(output_path, &#39;ori_mask.png&#39;), self.mask)

    def draw_mask_comparison(self, corrected_mask, output_path=&#39;./&#39;):
        img = np.zeros((*self.mask.shape, 3), dtype=np.uint8)
        self.mask[self.mask &gt; 0] = 255
        corrected_mask[corrected_mask &gt; 0] = 255
        img[:, :, 1] = self.mask
        img[:, :, 0] = corrected_mask
        cv2.imwrite(os.path.join(output_path, &#39;mask_comparison.png&#39;), img)

    @staticmethod
    def draw_corrected_mask(corrected_mask, output_path=&#39;./&#39;):
        corrected_mask[corrected_mask &gt; 0] = 255
        return corrected_mask
        # cv2.imwrite(os.path.join(output_path, &#39;correct_mask.png&#39;), corrected_mask)

    @staticmethod
    def create_cgef(cgef_file, bgef_file, mask_file, block_sizes=None):
        MatrixLoader.bgef2cgef(cgef_file, bgef_file, mask_file, block_sizes)

    def get_gem(self):
        return self.gem

    def set_matrix(self):
        if self.gem is None:
            clog.error(&#39;gem is None!&#39;)
        else:
            self.creat_cell_gxp()

    def get_matrix(self):
        return self.exp_matrix

    def creat_cell_gxp(self):
        clog.info(&#34;Loading mask file...&#34;)
        _, maskImg = cv2.connectedComponents(self.fast_mask, connectivity=8)
        clog.info(&#34;Reading data..&#34;)
        self.gem[&#39;x&#39;] -= self.gem[&#39;x&#39;].min()
        self.gem[&#39;y&#39;] -= self.gem[&#39;y&#39;].min()

        assert &#34;MIDCount&#34; in self.gem.columns
        self.gem[&#39;CellID&#39;] = maskImg[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]]
        self.exp_matrix = self.gem

    def get_gem_arr(self):
        if self.gem:
            gem_img = np.zeros([self.gem[&#39;y&#39;].max() + 1, self.gem[&#39;x&#39;].max() + 1], dtype=np.uint8)
            gem_img[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]] = 255
            return gem_img
        else:
            clog.error(&#39;Gem does not exist...&#39;)

    def get_exp_arr(self):
        if self.exp_matrix:
            exp_img = np.zeros([self.exp_matrix[&#39;y&#39;].max() + 1, self.exp_matrix[&#39;x&#39;].max() + 1], dtype=np.uint8)
            exp_img[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] = 255
            return exp_img
        else:
            clog.error(&#39;Exp matrix does not exist...&#39;)

    def compare_cell_size(self):
        _, maskImg_1 = cv2.connectedComponents(self.mask, connectivity=8)
        _, maskImg_2 = cv2.connectedComponents(self.fast_mask, connectivity=8)
        ori_dict = dict(zip(*np.unique(maskImg_1, return_counts=True)))
        new_dict = dict(zip(*np.unique(maskImg_2, return_counts=True)))
        merged = {k: (ori_dict[k], new_dict[k]) for k in ori_dict}
        return merged

    def cell_mid(self):
        gem = self.exp_matrix
        cell_gem = gem[self.mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
        fast_gem = gem[self.fast_mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
        cell_mid = cell_gem[&#39;MIDCount&#39;].sum()
        fast_mid = fast_gem[&#39;MIDCount&#39;].sum()
        return round(cell_mid / fast_mid, 3), round(cell_mid / len(gem), 3), round(fast_mid / len(gem), 3)

    def gene_number(self, type=&#39;fast&#39;, bin=20):
        if type == &#39;fast&#39;:
            mask = self.fast_mask
        else:
            mask = self.mask
        _, maskImg = cv2.connectedComponents(mask, connectivity=8)
        bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
        group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;]).agg(np.sum)
        idx = np.array(group.index.tolist())
        bin_img[idx[:, 1], idx[:, 0]] = group[&#39;MIDCount&#39;].tolist()
        # total = bin_img[res[&#39;y&#39;],res[&#39;x&#39;]].sum()
        total = bin_img.sum()
        y, x = np.where(mask &gt; 0)
        bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
        return int(total / bin_size), int(total / maskImg.max())

    def gene_type(self, type=&#39;fast&#39;, bin=20):
        if type == &#39;fast&#39;:
            mask = self.fast_mask
        else:
            mask = self.mask
        _, maskImg = cv2.connectedComponents(mask, connectivity=8)
        bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
        group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].unique()
        genid_list = [len(i) for i in group.values.tolist()]
        idx = np.array(group.index.tolist())
        bin_img[idx[:, 1], idx[:, 0]] = genid_list
        total = bin_img.sum()
        y, x = np.where(mask &gt; 0)
        bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
        return int(total / bin_size), int(total / maskImg.max())

    def get_rate(self):
        cell_gem = self.exp_matrix[self.mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
        fast_gem = self.exp_matrix[self.fast_mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
        gem_amount = len(self.exp_matrix)
        return [round(len(cell_gem) / gem_amount, 2), round(len(fast_gem) / gem_amount, 2)]

    def qc(self):
        bin_size = (self.exp_matrix[&#39;y&#39;].max() - self.exp_matrix[&#39;y&#39;].min()) * (
                    self.exp_matrix[&#39;x&#39;].max() - self.exp_matrix[&#39;x&#39;].min())
        bin200_size = bin_size / (200 ** 2)
        bin50_size = bin_size / (50 ** 2)
        gene_amount = np.sum(self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].size().tolist())
        gene_type = len(self.exp_matrix[&#39;geneID&#39;])

        if (gene_type / bin50_size) &lt; 500 or (gene_amount / bin200_size) &lt; 5000:
            clog.info(&#39;---QC failed!---&#39;)
        else:
            clog.info(&#39;---QC Success!---&#39;)

    def get_comparison(self):
        cell_size_dict = self.compare_cell_size()  # dict - {label:(before, after)}
        mid_list = self.cell_mid()  # List - [before/after MID, before/gem, after/gem]
        gene_num_ori = self.gene_number(&#39;ori&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
        gene_num_fast = self.gene_number(&#39;fast&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
        gene_type_ori = self.gene_type(&#39;ori&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
        gene_type_fast = self.gene_type(&#39;fast&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
        return cell_size_dict, mid_list, [gene_num_ori, gene_num_fast, gene_type_ori, gene_type_fast]


if __name__ == &#39;__main__&#39;:
    # a = MatrixLoader(r&#34;D:\git_libs\cellbin\test\C01333A3.gem.gz&#34;)
    # a.gem2bgef(gem_file = r&#34;D:\git_libs\cellbin\test\C01333A3.gem.gz&#34;, bgef_file=r&#34;D:\git_libs\cellbin\test\C01333A3.bgef&#34;, binsize=[1],region=None)
    # a.bgef2gem(bgef_file=r&#34;D:\git_libs\cellbin\test\C01333A3.bgef&#34;, gem_file = r&#34;D:\git_libs\cellbin\test\C01333A3_test.gem.gz&#34;, binsize=1)
    # from gefpy.bgef_reader_cy import BgefR
    # bgef_reader = BgefR(r&#34;D:\git_libs\cellbin\test\C01333A3.bgef&#34;,1,8)
    # explist = bgef_reader.get_expression()
    # gene_data = bgef_reader.get_gene_data()
    # print(explist)
    # print(gene_data)
    # print(len(gene_data[1]))
    import tifffile as tifi

    mask = tifi.imread(r&#34;D:\yiwen_correct_data\SS200000406TL_D1_mask.tif&#34;)
    lif = CellLabelling(mask,
                        r&#34;D:\yiwen_correct_data\SS200000406TL_D1.tissue.gem.gz&#34;)
    # fast = Fast(lif.mask)
    # fast.process()
    # fast_mask = fast.get_mask_fast()
    fast_mask, matx = lif.run_fast()
    output_path = r&#39;D:\yiwen_correct_data&#39;
    cv2.imwrite(os.path.join(output_path, &#39;correct_mask.png&#39;), fast_mask)
    # matx = lif.get_matrix()
    matx.to_csv(os.path.join(output_path, &#39;correct_mask.gem&#39;), sep=&#39;\t&#39;, index=False)
    lif.get_rate()
    lif.qc()
    # lif.draw_corrected_mask(fast_mask)
    # lif.draw_mask_comparison(fast_mask)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cellbin.modules.cell_labelling.CellLabelling"><code class="flex name class">
<span>class <span class="ident">CellLabelling</span></span>
<span>(</span><span>mask, gene_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CellLabelling(CellBinElement):
    def __init__(self, mask, gene_file):
        self.mask = None
        self.fast_mask = None
        self.gem = gene_file
        self.bgef = None
        self.cgef = None
        self.exp_matrix = None
        self.process = 8

        self.set_mask(mask)
        # self.set_gem(gene_file)
        # self.set_matrix()

    def set_process(self, p):
        self.process = p

    def run_fast(self, distance=10):
        f = Fast(self.mask, distance, self.process)
        f.process()
        self.set_fast_mask(f.mask)
        self.set_gem(self.gem)
        self.set_matrix()
        return f.mask, self.exp_matrix

    def run_gmm(self, threshold=20, process=10):
        g = GMM(self.exp_matrix, threshold, process)
        g.cell_correct()
        return None, g.gmm_result

    def set_mask(self, mask):
        try:
            # self.mask = tifi.imread(mask)
            self.mask = mask
            self.mask[self.mask &gt; 0] = 1
            self.mask = self.mask.astype(np.uint8)
        except:
            clog.error(f&#39;unable to load cell mask {mask}!&#39;)

    def set_fast_mask(self, mask):
        try:
            self.fast_mask = mask
            self.fast_mask[self.fast_mask &gt; 0] = 1
            self.fast_mask = self.fast_mask.astype(np.uint8)
        except:
            clog.error(f&#39;unable to load cell mask {mask}!&#39;)

    def set_gem(self, gene_file, new_file=&#39;temp.gem&#39;):
        # if gene_file.lower().endswith((&#39;.bgef&#39;, &#39;.gef&#39;)):
        #     from gefpy.bgef_reader_cy import BgefR
        #     self.bgef = BgefR(gene_file, 1, 8)
        #     ml = MatrixLoader(gene_file)
        #     ml.bgef2gem(bgef_file=gene_file, gem_file=new_file, binsize=1)
        #     self.gem = pd.read_csv(new_file, sep=&#39;\t&#39;, skiprows=6)
        # else:
        def row(gem_path):
            if gem_path.endswith(&#39;.gz&#39;):
                import gzip
                with gzip.open(gem_path, &#39;rb&#39;) as f:
                    first_line = bytes.decode(f.readline())
                    if &#39;#&#39; in first_line:
                        rows = 6
                    else:
                        rows = 0
            else:
                with open(gem_path, &#39;rb&#39;) as f:
                    first_line = bytes.decode(f.readline())
                    if &#39;#&#39; in first_line:
                        rows = 6
                    else:
                        rows = 0
            return rows

        self.gem = pd.read_csv(gene_file, sep=&#39;\t&#39;, skiprows=row(gene_file))
        # else:
        #     self.gem = None

    def draw_ori_mask(self, output_path):
        self.mask[self.mask &gt; 0] = 255
        cv2.imwrite(os.path.join(output_path, &#39;ori_mask.png&#39;), self.mask)

    def draw_mask_comparison(self, corrected_mask, output_path=&#39;./&#39;):
        img = np.zeros((*self.mask.shape, 3), dtype=np.uint8)
        self.mask[self.mask &gt; 0] = 255
        corrected_mask[corrected_mask &gt; 0] = 255
        img[:, :, 1] = self.mask
        img[:, :, 0] = corrected_mask
        cv2.imwrite(os.path.join(output_path, &#39;mask_comparison.png&#39;), img)

    @staticmethod
    def draw_corrected_mask(corrected_mask, output_path=&#39;./&#39;):
        corrected_mask[corrected_mask &gt; 0] = 255
        return corrected_mask
        # cv2.imwrite(os.path.join(output_path, &#39;correct_mask.png&#39;), corrected_mask)

    @staticmethod
    def create_cgef(cgef_file, bgef_file, mask_file, block_sizes=None):
        MatrixLoader.bgef2cgef(cgef_file, bgef_file, mask_file, block_sizes)

    def get_gem(self):
        return self.gem

    def set_matrix(self):
        if self.gem is None:
            clog.error(&#39;gem is None!&#39;)
        else:
            self.creat_cell_gxp()

    def get_matrix(self):
        return self.exp_matrix

    def creat_cell_gxp(self):
        clog.info(&#34;Loading mask file...&#34;)
        _, maskImg = cv2.connectedComponents(self.fast_mask, connectivity=8)
        clog.info(&#34;Reading data..&#34;)
        self.gem[&#39;x&#39;] -= self.gem[&#39;x&#39;].min()
        self.gem[&#39;y&#39;] -= self.gem[&#39;y&#39;].min()

        assert &#34;MIDCount&#34; in self.gem.columns
        self.gem[&#39;CellID&#39;] = maskImg[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]]
        self.exp_matrix = self.gem

    def get_gem_arr(self):
        if self.gem:
            gem_img = np.zeros([self.gem[&#39;y&#39;].max() + 1, self.gem[&#39;x&#39;].max() + 1], dtype=np.uint8)
            gem_img[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]] = 255
            return gem_img
        else:
            clog.error(&#39;Gem does not exist...&#39;)

    def get_exp_arr(self):
        if self.exp_matrix:
            exp_img = np.zeros([self.exp_matrix[&#39;y&#39;].max() + 1, self.exp_matrix[&#39;x&#39;].max() + 1], dtype=np.uint8)
            exp_img[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] = 255
            return exp_img
        else:
            clog.error(&#39;Exp matrix does not exist...&#39;)

    def compare_cell_size(self):
        _, maskImg_1 = cv2.connectedComponents(self.mask, connectivity=8)
        _, maskImg_2 = cv2.connectedComponents(self.fast_mask, connectivity=8)
        ori_dict = dict(zip(*np.unique(maskImg_1, return_counts=True)))
        new_dict = dict(zip(*np.unique(maskImg_2, return_counts=True)))
        merged = {k: (ori_dict[k], new_dict[k]) for k in ori_dict}
        return merged

    def cell_mid(self):
        gem = self.exp_matrix
        cell_gem = gem[self.mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
        fast_gem = gem[self.fast_mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
        cell_mid = cell_gem[&#39;MIDCount&#39;].sum()
        fast_mid = fast_gem[&#39;MIDCount&#39;].sum()
        return round(cell_mid / fast_mid, 3), round(cell_mid / len(gem), 3), round(fast_mid / len(gem), 3)

    def gene_number(self, type=&#39;fast&#39;, bin=20):
        if type == &#39;fast&#39;:
            mask = self.fast_mask
        else:
            mask = self.mask
        _, maskImg = cv2.connectedComponents(mask, connectivity=8)
        bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
        group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;]).agg(np.sum)
        idx = np.array(group.index.tolist())
        bin_img[idx[:, 1], idx[:, 0]] = group[&#39;MIDCount&#39;].tolist()
        # total = bin_img[res[&#39;y&#39;],res[&#39;x&#39;]].sum()
        total = bin_img.sum()
        y, x = np.where(mask &gt; 0)
        bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
        return int(total / bin_size), int(total / maskImg.max())

    def gene_type(self, type=&#39;fast&#39;, bin=20):
        if type == &#39;fast&#39;:
            mask = self.fast_mask
        else:
            mask = self.mask
        _, maskImg = cv2.connectedComponents(mask, connectivity=8)
        bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
        group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].unique()
        genid_list = [len(i) for i in group.values.tolist()]
        idx = np.array(group.index.tolist())
        bin_img[idx[:, 1], idx[:, 0]] = genid_list
        total = bin_img.sum()
        y, x = np.where(mask &gt; 0)
        bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
        return int(total / bin_size), int(total / maskImg.max())

    def get_rate(self):
        cell_gem = self.exp_matrix[self.mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
        fast_gem = self.exp_matrix[self.fast_mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
        gem_amount = len(self.exp_matrix)
        return [round(len(cell_gem) / gem_amount, 2), round(len(fast_gem) / gem_amount, 2)]

    def qc(self):
        bin_size = (self.exp_matrix[&#39;y&#39;].max() - self.exp_matrix[&#39;y&#39;].min()) * (
                    self.exp_matrix[&#39;x&#39;].max() - self.exp_matrix[&#39;x&#39;].min())
        bin200_size = bin_size / (200 ** 2)
        bin50_size = bin_size / (50 ** 2)
        gene_amount = np.sum(self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].size().tolist())
        gene_type = len(self.exp_matrix[&#39;geneID&#39;])

        if (gene_type / bin50_size) &lt; 500 or (gene_amount / bin200_size) &lt; 5000:
            clog.info(&#39;---QC failed!---&#39;)
        else:
            clog.info(&#39;---QC Success!---&#39;)

    def get_comparison(self):
        cell_size_dict = self.compare_cell_size()  # dict - {label:(before, after)}
        mid_list = self.cell_mid()  # List - [before/after MID, before/gem, after/gem]
        gene_num_ori = self.gene_number(&#39;ori&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
        gene_num_fast = self.gene_number(&#39;fast&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
        gene_type_ori = self.gene_type(&#39;ori&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
        gene_type_fast = self.gene_type(&#39;fast&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
        return cell_size_dict, mid_list, [gene_num_ori, gene_num_fast, gene_type_ori, gene_type_fast]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cellbin.modules.CellBinElement" href="index.html#cellbin.modules.CellBinElement">CellBinElement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cellbin.modules.cell_labelling.CellLabelling.create_cgef"><code class="name flex">
<span>def <span class="ident">create_cgef</span></span>(<span>cgef_file, bgef_file, mask_file, block_sizes=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_cgef(cgef_file, bgef_file, mask_file, block_sizes=None):
    MatrixLoader.bgef2cgef(cgef_file, bgef_file, mask_file, block_sizes)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.draw_corrected_mask"><code class="name flex">
<span>def <span class="ident">draw_corrected_mask</span></span>(<span>corrected_mask, output_path='./')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def draw_corrected_mask(corrected_mask, output_path=&#39;./&#39;):
    corrected_mask[corrected_mask &gt; 0] = 255
    return corrected_mask
    # cv2.imwrite(os.path.join(output_path, &#39;correct_mask.png&#39;), corrected_mask)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cellbin.modules.cell_labelling.CellLabelling.cell_mid"><code class="name flex">
<span>def <span class="ident">cell_mid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_mid(self):
    gem = self.exp_matrix
    cell_gem = gem[self.mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
    fast_gem = gem[self.fast_mask[gem[&#39;y&#39;], gem[&#39;x&#39;]] &gt; 0]
    cell_mid = cell_gem[&#39;MIDCount&#39;].sum()
    fast_mid = fast_gem[&#39;MIDCount&#39;].sum()
    return round(cell_mid / fast_mid, 3), round(cell_mid / len(gem), 3), round(fast_mid / len(gem), 3)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.compare_cell_size"><code class="name flex">
<span>def <span class="ident">compare_cell_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_cell_size(self):
    _, maskImg_1 = cv2.connectedComponents(self.mask, connectivity=8)
    _, maskImg_2 = cv2.connectedComponents(self.fast_mask, connectivity=8)
    ori_dict = dict(zip(*np.unique(maskImg_1, return_counts=True)))
    new_dict = dict(zip(*np.unique(maskImg_2, return_counts=True)))
    merged = {k: (ori_dict[k], new_dict[k]) for k in ori_dict}
    return merged</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.creat_cell_gxp"><code class="name flex">
<span>def <span class="ident">creat_cell_gxp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creat_cell_gxp(self):
    clog.info(&#34;Loading mask file...&#34;)
    _, maskImg = cv2.connectedComponents(self.fast_mask, connectivity=8)
    clog.info(&#34;Reading data..&#34;)
    self.gem[&#39;x&#39;] -= self.gem[&#39;x&#39;].min()
    self.gem[&#39;y&#39;] -= self.gem[&#39;y&#39;].min()

    assert &#34;MIDCount&#34; in self.gem.columns
    self.gem[&#39;CellID&#39;] = maskImg[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]]
    self.exp_matrix = self.gem</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.draw_mask_comparison"><code class="name flex">
<span>def <span class="ident">draw_mask_comparison</span></span>(<span>self, corrected_mask, output_path='./')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_mask_comparison(self, corrected_mask, output_path=&#39;./&#39;):
    img = np.zeros((*self.mask.shape, 3), dtype=np.uint8)
    self.mask[self.mask &gt; 0] = 255
    corrected_mask[corrected_mask &gt; 0] = 255
    img[:, :, 1] = self.mask
    img[:, :, 0] = corrected_mask
    cv2.imwrite(os.path.join(output_path, &#39;mask_comparison.png&#39;), img)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.draw_ori_mask"><code class="name flex">
<span>def <span class="ident">draw_ori_mask</span></span>(<span>self, output_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ori_mask(self, output_path):
    self.mask[self.mask &gt; 0] = 255
    cv2.imwrite(os.path.join(output_path, &#39;ori_mask.png&#39;), self.mask)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.gene_number"><code class="name flex">
<span>def <span class="ident">gene_number</span></span>(<span>self, type='fast', bin=20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gene_number(self, type=&#39;fast&#39;, bin=20):
    if type == &#39;fast&#39;:
        mask = self.fast_mask
    else:
        mask = self.mask
    _, maskImg = cv2.connectedComponents(mask, connectivity=8)
    bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
    group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;]).agg(np.sum)
    idx = np.array(group.index.tolist())
    bin_img[idx[:, 1], idx[:, 0]] = group[&#39;MIDCount&#39;].tolist()
    # total = bin_img[res[&#39;y&#39;],res[&#39;x&#39;]].sum()
    total = bin_img.sum()
    y, x = np.where(mask &gt; 0)
    bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
    return int(total / bin_size), int(total / maskImg.max())</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.gene_type"><code class="name flex">
<span>def <span class="ident">gene_type</span></span>(<span>self, type='fast', bin=20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gene_type(self, type=&#39;fast&#39;, bin=20):
    if type == &#39;fast&#39;:
        mask = self.fast_mask
    else:
        mask = self.mask
    _, maskImg = cv2.connectedComponents(mask, connectivity=8)
    bin_img = np.zeros((mask.shape[0], mask.shape[1]), dtype=np.uint16)
    group = self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].unique()
    genid_list = [len(i) for i in group.values.tolist()]
    idx = np.array(group.index.tolist())
    bin_img[idx[:, 1], idx[:, 0]] = genid_list
    total = bin_img.sum()
    y, x = np.where(mask &gt; 0)
    bin_size = (y.max() - y.min()) * (x.max() - x.min()) / (bin ** 2)
    return int(total / bin_size), int(total / maskImg.max())</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_comparison"><code class="name flex">
<span>def <span class="ident">get_comparison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_comparison(self):
    cell_size_dict = self.compare_cell_size()  # dict - {label:(before, after)}
    mid_list = self.cell_mid()  # List - [before/after MID, before/gem, after/gem]
    gene_num_ori = self.gene_number(&#39;ori&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
    gene_num_fast = self.gene_number(&#39;fast&#39;, 20)  # int, int - bin20 gene number, cellbin gene number
    gene_type_ori = self.gene_type(&#39;ori&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
    gene_type_fast = self.gene_type(&#39;fast&#39;, 50)  # int, int - bin50 gene type, cellbin gene number
    return cell_size_dict, mid_list, [gene_num_ori, gene_num_fast, gene_type_ori, gene_type_fast]</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_exp_arr"><code class="name flex">
<span>def <span class="ident">get_exp_arr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exp_arr(self):
    if self.exp_matrix:
        exp_img = np.zeros([self.exp_matrix[&#39;y&#39;].max() + 1, self.exp_matrix[&#39;x&#39;].max() + 1], dtype=np.uint8)
        exp_img[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] = 255
        return exp_img
    else:
        clog.error(&#39;Exp matrix does not exist...&#39;)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_gem"><code class="name flex">
<span>def <span class="ident">get_gem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gem(self):
    return self.gem</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_gem_arr"><code class="name flex">
<span>def <span class="ident">get_gem_arr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gem_arr(self):
    if self.gem:
        gem_img = np.zeros([self.gem[&#39;y&#39;].max() + 1, self.gem[&#39;x&#39;].max() + 1], dtype=np.uint8)
        gem_img[self.gem[&#39;y&#39;], self.gem[&#39;x&#39;]] = 255
        return gem_img
    else:
        clog.error(&#39;Gem does not exist...&#39;)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix(self):
    return self.exp_matrix</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.get_rate"><code class="name flex">
<span>def <span class="ident">get_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rate(self):
    cell_gem = self.exp_matrix[self.mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
    fast_gem = self.exp_matrix[self.fast_mask[self.exp_matrix[&#39;y&#39;], self.exp_matrix[&#39;x&#39;]] &gt; 0]
    gem_amount = len(self.exp_matrix)
    return [round(len(cell_gem) / gem_amount, 2), round(len(fast_gem) / gem_amount, 2)]</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.qc"><code class="name flex">
<span>def <span class="ident">qc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qc(self):
    bin_size = (self.exp_matrix[&#39;y&#39;].max() - self.exp_matrix[&#39;y&#39;].min()) * (
                self.exp_matrix[&#39;x&#39;].max() - self.exp_matrix[&#39;x&#39;].min())
    bin200_size = bin_size / (200 ** 2)
    bin50_size = bin_size / (50 ** 2)
    gene_amount = np.sum(self.exp_matrix.groupby([&#39;x&#39;, &#39;y&#39;])[&#39;geneID&#39;].size().tolist())
    gene_type = len(self.exp_matrix[&#39;geneID&#39;])

    if (gene_type / bin50_size) &lt; 500 or (gene_amount / bin200_size) &lt; 5000:
        clog.info(&#39;---QC failed!---&#39;)
    else:
        clog.info(&#39;---QC Success!---&#39;)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.run_fast"><code class="name flex">
<span>def <span class="ident">run_fast</span></span>(<span>self, distance=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_fast(self, distance=10):
    f = Fast(self.mask, distance, self.process)
    f.process()
    self.set_fast_mask(f.mask)
    self.set_gem(self.gem)
    self.set_matrix()
    return f.mask, self.exp_matrix</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.run_gmm"><code class="name flex">
<span>def <span class="ident">run_gmm</span></span>(<span>self, threshold=20, process=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gmm(self, threshold=20, process=10):
    g = GMM(self.exp_matrix, threshold, process)
    g.cell_correct()
    return None, g.gmm_result</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.set_fast_mask"><code class="name flex">
<span>def <span class="ident">set_fast_mask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fast_mask(self, mask):
    try:
        self.fast_mask = mask
        self.fast_mask[self.fast_mask &gt; 0] = 1
        self.fast_mask = self.fast_mask.astype(np.uint8)
    except:
        clog.error(f&#39;unable to load cell mask {mask}!&#39;)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.set_gem"><code class="name flex">
<span>def <span class="ident">set_gem</span></span>(<span>self, gene_file, new_file='temp.gem')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gem(self, gene_file, new_file=&#39;temp.gem&#39;):
    # if gene_file.lower().endswith((&#39;.bgef&#39;, &#39;.gef&#39;)):
    #     from gefpy.bgef_reader_cy import BgefR
    #     self.bgef = BgefR(gene_file, 1, 8)
    #     ml = MatrixLoader(gene_file)
    #     ml.bgef2gem(bgef_file=gene_file, gem_file=new_file, binsize=1)
    #     self.gem = pd.read_csv(new_file, sep=&#39;\t&#39;, skiprows=6)
    # else:
    def row(gem_path):
        if gem_path.endswith(&#39;.gz&#39;):
            import gzip
            with gzip.open(gem_path, &#39;rb&#39;) as f:
                first_line = bytes.decode(f.readline())
                if &#39;#&#39; in first_line:
                    rows = 6
                else:
                    rows = 0
        else:
            with open(gem_path, &#39;rb&#39;) as f:
                first_line = bytes.decode(f.readline())
                if &#39;#&#39; in first_line:
                    rows = 6
                else:
                    rows = 0
        return rows

    self.gem = pd.read_csv(gene_file, sep=&#39;\t&#39;, skiprows=row(gene_file))
    # else:
    #     self.gem = None</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.set_mask"><code class="name flex">
<span>def <span class="ident">set_mask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mask(self, mask):
    try:
        # self.mask = tifi.imread(mask)
        self.mask = mask
        self.mask[self.mask &gt; 0] = 1
        self.mask = self.mask.astype(np.uint8)
    except:
        clog.error(f&#39;unable to load cell mask {mask}!&#39;)</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.set_matrix"><code class="name flex">
<span>def <span class="ident">set_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_matrix(self):
    if self.gem is None:
        clog.error(&#39;gem is None!&#39;)
    else:
        self.creat_cell_gxp()</code></pre>
</details>
</dd>
<dt id="cellbin.modules.cell_labelling.CellLabelling.set_process"><code class="name flex">
<span>def <span class="ident">set_process</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_process(self, p):
    self.process = p</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cellbin.modules" href="index.html">cellbin.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cellbin.modules.cell_labelling.CellLabelling" href="#cellbin.modules.cell_labelling.CellLabelling">CellLabelling</a></code></h4>
<ul class="">
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.cell_mid" href="#cellbin.modules.cell_labelling.CellLabelling.cell_mid">cell_mid</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.compare_cell_size" href="#cellbin.modules.cell_labelling.CellLabelling.compare_cell_size">compare_cell_size</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.creat_cell_gxp" href="#cellbin.modules.cell_labelling.CellLabelling.creat_cell_gxp">creat_cell_gxp</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.create_cgef" href="#cellbin.modules.cell_labelling.CellLabelling.create_cgef">create_cgef</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.draw_corrected_mask" href="#cellbin.modules.cell_labelling.CellLabelling.draw_corrected_mask">draw_corrected_mask</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.draw_mask_comparison" href="#cellbin.modules.cell_labelling.CellLabelling.draw_mask_comparison">draw_mask_comparison</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.draw_ori_mask" href="#cellbin.modules.cell_labelling.CellLabelling.draw_ori_mask">draw_ori_mask</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.gene_number" href="#cellbin.modules.cell_labelling.CellLabelling.gene_number">gene_number</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.gene_type" href="#cellbin.modules.cell_labelling.CellLabelling.gene_type">gene_type</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_comparison" href="#cellbin.modules.cell_labelling.CellLabelling.get_comparison">get_comparison</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_exp_arr" href="#cellbin.modules.cell_labelling.CellLabelling.get_exp_arr">get_exp_arr</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_gem" href="#cellbin.modules.cell_labelling.CellLabelling.get_gem">get_gem</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_gem_arr" href="#cellbin.modules.cell_labelling.CellLabelling.get_gem_arr">get_gem_arr</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_matrix" href="#cellbin.modules.cell_labelling.CellLabelling.get_matrix">get_matrix</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.get_rate" href="#cellbin.modules.cell_labelling.CellLabelling.get_rate">get_rate</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.qc" href="#cellbin.modules.cell_labelling.CellLabelling.qc">qc</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.run_fast" href="#cellbin.modules.cell_labelling.CellLabelling.run_fast">run_fast</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.run_gmm" href="#cellbin.modules.cell_labelling.CellLabelling.run_gmm">run_gmm</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.set_fast_mask" href="#cellbin.modules.cell_labelling.CellLabelling.set_fast_mask">set_fast_mask</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.set_gem" href="#cellbin.modules.cell_labelling.CellLabelling.set_gem">set_gem</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.set_mask" href="#cellbin.modules.cell_labelling.CellLabelling.set_mask">set_mask</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.set_matrix" href="#cellbin.modules.cell_labelling.CellLabelling.set_matrix">set_matrix</a></code></li>
<li><code><a title="cellbin.modules.cell_labelling.CellLabelling.set_process" href="#cellbin.modules.cell_labelling.CellLabelling.set_process">set_process</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>